{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastOpenAPI","text":"<p> FastOpenAPI ist eine Bibliothek zur Generierung und Integration von OpenAPI-Schemas mit Pydantic und verschiedenen Frameworks. </p> <p>   Dieses Projekt wurde von FastAPI inspiriert und zielt darauf ab, eine \u00e4hnlich entwicklerfreundliche Erfahrung zu bieten. </p> <p> </p>"},{"location":"#uber-das-projekt","title":"\u00dcber das Projekt","text":"<p>FastOpenAPI ist eine Python-Bibliothek zur Generierung und Integration von OpenAPI-Schemas mithilfe von Pydantic-Modellen in verschiedenen Webframeworks. Inspiriert von FastAPI bietet sie eine vergleichbare Entwicklererfahrung \u2013 aber f\u00fcr Frameworks wie AIOHTTP, Falcon, Flask, Quart, Sanic, Starlette und Tornado. Mit FastOpenAPI kannst du interaktive API-Dokumentation und automatische Validierung zu bestehenden Projekten hinzuf\u00fcgen, ohne das Framework wechseln zu m\u00fcssen.</p> <p>FastOpenAPI befindet sich derzeit in aktiver Entwicklung (noch vor Version 1.0). Die Bibliothek ist schon jetzt einsatzf\u00e4hig, aber \u00c4nderungen sind m\u00f6glich. Feedback und Beitr\u00e4ge sind sehr willkommen.</p>"},{"location":"#merkmale","title":"Merkmale","text":"<ul> <li>Automatische OpenAPI-Generierung \u2013 definiere deine Routen und Modelle, FastOpenAPI erstellt automatisch eine vollst\u00e4ndige OpenAPI-Spezifikation.</li> <li>Unterst\u00fctzung f\u00fcr Pydantic v2 \u2013 nutzt Pydantic zur Validierung und Serialisierung von Daten, sowohl f\u00fcr Anfragen als auch f\u00fcr Antworten.</li> <li>Multi-Framework-Unterst\u00fctzung \u2013 unterst\u00fctzt AIOHTTP, Falcon, Flask, Quart, Sanic, Starlette und Tornado.</li> <li>FastAPI-\u00e4hnlicher Routing-Stil \u2013 verwende <code>@router.get</code>, <code>@router.post</code> etc., \u00e4hnlich wie bei FastAPI.</li> <li>Interaktive Dokumentation \u2013 Swagger UI (<code>/docs</code>) und ReDoc (<code>/redoc</code>) sind direkt integriert.</li> <li>Fehlerbehandlung und Validierung \u2013 bei ung\u00fcltigen Daten wird ein JSON-Fehler zur\u00fcckgegeben. Enth\u00e4lt Standardfehlerklassen f\u00fcr 400, 404 usw.</li> </ul> <p>Verwende die Navigation auf der linken Seite, um die Dokumentation zu erkunden. Beginne mit den Abschnitten Installation und Schnellstart, und fahre fort mit Verwendung. F\u00fcr jedes unterst\u00fctzte Framework gibt es eine eigene Seite. Fortgeschrittene Themen findest du unter Erweiterte Nutzung und API-Referenz. Wenn du mithelfen m\u00f6chtest, schau unter Mitwirken. \u00c4nderungen findest du im Changelog, h\u00e4ufige Fragen unter FAQ.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Alle bedeutenden \u00c4nderungen an FastOpenAPI werden in dieser Datei dokumentiert.</p>"},{"location":"changelog/#050-2025-04-13","title":"[0.5.0] \u2013 2025-04-13","text":""},{"location":"changelog/#hinzugefugt","title":"Hinzugef\u00fcgt","text":"<ul> <li>AioHttpRouter zur Integration mit dem AIOHTTP-Framework (async-Unterst\u00fctzung).</li> <li>Klassencache f\u00fcr Pydantic-Model-Schemas zur Leistungsverbesserung (vermeidet wiederholte Generierung von JSON Schema).</li> <li><code>response_errors</code>-Parameter f\u00fcr Routen-Dekoratoren, um Fehlerr\u00fcckgaben in OpenAPI zu dokumentieren.</li> <li>Modul <code>error_handler</code> f\u00fcr standardisierte Fehlerantworten (stellt Fehlerklassen wie <code>BadRequestError</code>, <code>ResourceNotFoundError</code> usw. bereit).</li> <li>Unterst\u00fctzung einfacher Python-Typen (<code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code>) als <code>response_model</code>.</li> </ul>"},{"location":"changelog/#040-20032025","title":"[0.4.0] \u2013 20.03.2025","text":""},{"location":"changelog/#hinzugefugt_1","title":"Hinzugef\u00fcgt","text":"<ul> <li>Unterst\u00fctzung f\u00fcr ReDoc UI (verf\u00fcgbar unter <code>/redoc</code>).</li> <li>TornadoRouter f\u00fcr das Tornado-Framework.</li> </ul>"},{"location":"changelog/#geandert","title":"Ge\u00e4ndert","text":"<ul> <li>Alle Tests \u00fcberarbeitet zur Verbesserung der Abdeckung und Zuverl\u00e4ssigkeit.</li> </ul>"},{"location":"changelog/#behoben","title":"Behoben","text":"<ul> <li>Fehlercode bei internen Fehlern ge\u00e4ndert: von 422 auf 500, gem\u00e4\u00df HTTP-Standards.</li> </ul>"},{"location":"changelog/#entfernt","title":"Entfernt","text":"<ul> <li><code>add_docs_route</code> und <code>add_openapi_route</code> Methoden aus <code>BaseRouter</code> entfernt \u2013 Dokumentationsrouten werden jetzt automatisch hinzugef\u00fcgt.</li> </ul>"},{"location":"changelog/#031-15032025","title":"[0.3.1] \u2013 15.03.2025","text":""},{"location":"changelog/#behoben_1","title":"Behoben","text":"<ul> <li>Fehler beim Import von Routern ohne installiertes Framework (Abfangen von <code>ModuleNotFoundError</code>).</li> </ul>"},{"location":"changelog/#030-15032025","title":"[0.3.0] \u2013 15.03.2025","text":""},{"location":"changelog/#hinzugefugt_2","title":"Hinzugef\u00fcgt","text":"<ul> <li>QuartRouter f\u00fcr das Quart-Framework (async).</li> <li>Erste Dokumentation (Einf\u00fchrung und Grundbeispiele) im Repository.</li> </ul>"},{"location":"changelog/#geandert_1","title":"Ge\u00e4ndert","text":"<ul> <li>Vereinfachter Import: jetzt <code>from fastopenapi.routers import YourRouter</code>.</li> </ul>"},{"location":"changelog/#behoben_2","title":"Behoben","text":"<ul> <li>Query-Parameter \u00fcber Pydantic-Modelle in GET-Routen werden nun korrekt erkannt und genutzt.</li> </ul>"},{"location":"changelog/#021-12032025","title":"[0.2.1] \u2013 12.03.2025","text":""},{"location":"changelog/#behoben_3","title":"Behoben","text":"<ul> <li>Serialisierung von Antworten: <code>_serialize_response</code> konvertiert BaseModel jetzt korrekt in ein dict vor JSON.</li> <li>Fehler im <code>DataLoader</code> bei leeren Daten beseitigt.</li> <li>Zus\u00e4tzliche Tests f\u00fcr obige F\u00e4lle hinzugef\u00fcgt.</li> <li>Diese Changelog-Datei (<code>CHANGELOG.md</code>) hinzugef\u00fcgt.</li> </ul>"},{"location":"changelog/#020-11032025","title":"[0.2.0] \u2013 11.03.2025","text":""},{"location":"changelog/#hinzugefugt_3","title":"Hinzugef\u00fcgt","text":"<ul> <li><code>resolve_endpoint_params</code> in <code>BaseRouter</code> implementiert zur Parameterauswertung (path, query, body).</li> <li><code>prefix</code>-Support in <code>include_router</code> zur Gruppierung von Routen.</li> <li><code>status_code</code>-Support in Dekoratoren (Default-Statuscode setzen).</li> </ul>"},{"location":"changelog/#geandert_2","title":"Ge\u00e4ndert","text":"<ul> <li>Refactoring aller Router-Implementierungen zur Vereinheitlichung und Reduzierung von Redundanz.</li> </ul>"},{"location":"changelog/#entfernt_1","title":"Entfernt","text":"<ul> <li><code>register_routes</code> aus Starlette-Implementierung entfernt (veraltet durch Refactoring).</li> </ul>"},{"location":"changelog/#010-01032025","title":"[0.1.0] \u2013 01.03.2025","text":""},{"location":"changelog/#hinzugefugt_4","title":"Hinzugef\u00fcgt","text":"<ul> <li>Erste Ver\u00f6ffentlichung von FastOpenAPI.</li> <li>Grundfunktionalit\u00e4t implementiert:</li> <li>Basisrouter-Klassen</li> <li>Unterst\u00fctzung f\u00fcr Falcon, Flask, Sanic, Starlette</li> <li>OpenAPI-Schema-Generierung \u00fcber Pydantic v2</li> <li>Parameter- und Body-Validierung</li> <li>README und einfache Beispiele hinzugef\u00fcgt.</li> <li>Erste Tests zur Schema-Generierung und Routenregistrierung integriert.</li> </ul>"},{"location":"contributing/","title":"Willkommen!","text":"<p>Vielen Dank, dass du zur Entwicklung von FastOpenAPI beitragen m\u00f6chtest \ud83c\udf89 Dieses Dokument erkl\u00e4rt, wie du loslegen kannst, Beitr\u00e4ge leistest, Commits erstellst, Pull Requests einreichst und Tests ausf\u00fchrst.</p>"},{"location":"contributing/#einrichtung-ausfuhrung","title":"Einrichtung &amp; Ausf\u00fchrung","text":"<p>Installiere Abh\u00e4ngigkeiten mit:</p> <pre><code># Fork the repo on GitHub first, then:\ngit clone https://github.com/yourusername/fastopenapi.git\ncd fastopenapi\npoetry install\n</code></pre> <p>Wenn du kein <code>poetry</code> verwendest, kannst du manuell installieren:</p> <pre><code>pip install -e .[dev]\n</code></pre>"},{"location":"contributing/#projektstruktur","title":"Projektstruktur","text":"<ul> <li><code>fastopenapi/</code> \u2014 Hauptbibliothek</li> <li><code>examples/</code> \u2014 Beispiele f\u00fcr verschiedene Frameworks</li> <li><code>tests/</code> \u2014 Testf\u00e4lle f\u00fcr jedes unterst\u00fctzte Framework</li> <li><code>benchmarks/</code> \u2014 Performance-Tests</li> <li><code>docs/</code> \u2014 Dokumentation in mehreren Sprachen</li> </ul>"},{"location":"contributing/#tests-ausfuhren","title":"Tests ausf\u00fchren","text":"<p>Starte die Tests mit:</p> <pre><code>pytest\n</code></pre> <p>Es werden sowohl Kernfunktionen als auch Framework-Integrationen (aiohttp, flask, sanic usw.) abgedeckt.</p>"},{"location":"contributing/#code-stil","title":"Code-Stil","text":"<p>Verwendete Tools:</p> <ul> <li><code>black</code> \u2014 Formatierung</li> <li><code>flake8</code> \u2014 Linting</li> <li><code>isort</code> \u2014 Imports sortieren</li> <li><code>pre-commit</code> \u2014 Pre-Commit-Hooks</li> </ul> <p>Pre-Commit installieren:</p> <pre><code>pre-commit install\n</code></pre> <p>Manuell ausf\u00fchren:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#git-pull-requests","title":"Git &amp; Pull Requests","text":"<ol> <li>Forke das Repository</li> <li>Erstelle einen Branch: <code>feature/dein-feature</code> oder <code>fix/dein-fix</code></li> <li>Verwende sinnvolle, kleine Commits</li> <li>\u00d6ffne einen PR mit Beschreibung:</li> <li>Was wurde ge\u00e4ndert oder hinzugef\u00fcgt?</li> <li>Welche Frameworks sind betroffen?</li> <li>Wie wurde getestet?</li> </ol>"},{"location":"contributing/#dokumentation","title":"Dokumentation","text":"<p>Wenn du APIs oder Verhalten \u00e4nderst, aktualisiere bitte auch die Dokumentation:</p> <ul> <li><code>docs/en/</code> (Hauptdokumentation)</li> <li>Optional: \u00dcbersetzungen (<code>docs/de/</code>, <code>docs/ru/</code>)</li> </ul>"},{"location":"contributing/#feedback-fragen","title":"Feedback &amp; Fragen","text":"<p>Du bist unsicher bei einer Idee? Er\u00f6ffne ein GitHub-Issue oder diskutiere mit dem Team \u2014 wir helfen gerne weiter!</p>"},{"location":"faq/","title":"FAQ (H\u00e4ufig gestellte Fragen)","text":"<p>Hier findest du Antworten auf h\u00e4ufige Fragen zu FastOpenAPI. Falls deine Frage hier nicht beantwortet wird, kannst du gerne ein Issue auf GitHub er\u00f6ffnen oder uns direkt kontaktieren.</p>"},{"location":"faq/#f-was-ist-fastopenapi-und-wie-unterscheidet-es-sich-von-fastapi","title":"F: Was ist FastOpenAPI und wie unterscheidet es sich von FastAPI?","text":"<p>A: FastOpenAPI ist kein Webframework, sondern eine Bibliothek, die OpenAPI/Swagger-Dokumentation und Request/Response-Validierung zu bestehenden Webframeworks (wie Flask, AIOHTTP usw.) hinzuf\u00fcgt. FastAPI hingegen ist ein vollst\u00e4ndiges Webframework mit integrierter OpenAPI-Unterst\u00fctzung. FastOpenAPI wurde von FastAPI inspiriert, ist aber daf\u00fcr gedacht, \u00e4hnliche Vorteile in anderen Frameworks bereitzustellen. Kurz: Verwende FastAPI, wenn du ein neues Projekt startest. Nutze FastOpenAPI, wenn du bereits ein Projekt in einem anderen Framework hast oder mehrere Frameworks unterst\u00fctzen m\u00f6chtest.</p>"},{"location":"faq/#f-welche-webframeworks-werden-unterstutzt","title":"F: Welche Webframeworks werden unterst\u00fctzt?","text":"<p>A: Unterst\u00fctzt werden:</p> <ul> <li>AIOHTTP (asynchroner HTTP-Server/Framework)</li> <li>Falcon (unterst\u00fctzt ASGI und WSGI)</li> <li>Flask (klassisches synchrones WSGI-Framework)</li> <li>Quart (asynchrones Framework mit Flask-\u00e4hnlicher API)</li> <li>Sanic (schnelles asynchrones Framework)</li> <li>Starlette (leichtgewichtiges ASGI-Framework)</li> <li>Tornado (Webframework und Netzwerkbibliothek)</li> </ul> <p>FastOpenAPI ist modular und leicht erweiterbar, sodass in Zukunft weitere Adapter folgen k\u00f6nnen. Du kannst auch einen eigenen <code>Router</code> schreiben (siehe Abschnitt \"Advanced Usage\").</p>"},{"location":"faq/#f-welche-python-und-pydantic-versionen-werden-benotigt","title":"F: Welche Python- und Pydantic-Versionen werden ben\u00f6tigt?","text":"<p>A: FastOpenAPI erfordert Python 3.10+ und nutzt Pydantic v2 zur Validierung und Schema-Generierung. Pydantic v2 erstellt JSON Schema kompatibel mit OpenAPI 3.1.</p>"},{"location":"faq/#f-wie-dokumentiert-man-authentifizierung-z-b-jwt-api-keys","title":"F: Wie dokumentiert man Authentifizierung (z.\u202fB. JWT, API Keys)?","text":"<p>A: FastOpenAPI implementiert keine Authentifizierungsmechanismen. Diese bleiben Sache des Frameworks. Du kannst aber <code>securitySchemes</code> in der OpenAPI-Spezifikation manuell erg\u00e4nzen (siehe \u201eAdvanced Usage\u201c). Wenn du z.\u202fB. ein JWT im Header erwartest, kannst du einfach ein <code>token: str</code> Argument angeben. Die Validierung erfolgt dann in deiner Middleware oder deinen Decorators.</p>"},{"location":"faq/#f-die-dokumentationsseiten-docs-redoc-funktionieren-nicht-was-tun","title":"F: Die Dokumentationsseiten (/docs, /redoc) funktionieren nicht. Was tun?","text":"<p>A: Stelle sicher, dass du das App-Objekt korrekt \u00fcbergeben hast (<code>router = FrameworkRouter(app=app)</code>). Ohne dies werden keine Routen registriert. Pr\u00fcfe au\u00dferdem, ob dein Server l\u00e4uft und ob evtl. ein URL-Pr\u00e4fix verwendet wird.</p>"},{"location":"faq/#f-kann-man-fastopenapi-mit-anderen-schema-generatoren-wie-flask-restx-kombinieren","title":"F: Kann man FastOpenAPI mit anderen Schema-Generatoren wie Flask-RESTx kombinieren?","text":"<p>A: Davon wird abgeraten. Zwei parallele Generatoren k\u00f6nnen zu Konflikten f\u00fchren. FastOpenAPI ist als Ersatz konzipiert. Falls du es dennoch einsetzt, deaktiviere andere automatische Dokumentationsl\u00f6sungen.</p>"},{"location":"faq/#f-unterstutzt-fastopenapi-dependency-injection-oder-features-wie-background-tasks","title":"F: Unterst\u00fctzt FastOpenAPI Dependency Injection oder Features wie Background Tasks?","text":"<p>A: Nein. FastOpenAPI k\u00fcmmert sich nur um Routing, Validierung und Dokumentation. Dependency Injection und Background Tasks m\u00fcssen vom jeweiligen Framework bereitgestellt werden.</p>"},{"location":"faq/#f-ist-fastopenapi-produktionsreif","title":"F: Ist FastOpenAPI produktionsreif?","text":"<p>A: FastOpenAPI befindet sich in aktiver Entwicklung (pre-1.0). Viele Features sind stabil, aber \u00c4nderungen sind m\u00f6glich. Fixiere die Version in <code>requirements.txt</code> und teste regelm\u00e4\u00dfig. Die Schema-Generierung ist sicher, da sie nur lesend arbeitet.</p>"},{"location":"faq/#f-wie-kann-ich-beitragen-oder-fehler-melden","title":"F: Wie kann ich beitragen oder Fehler melden?","text":"<p>A: Beitr\u00e4ge sind willkommen! Lies den Abschnitt Contributing. Du kannst ein Issue oder einen Pull Request auf GitHub erstellen.</p>"},{"location":"faq/#f-gibt-es-beispielprojekte-die-fastopenapi-nutzen","title":"F: Gibt es Beispielprojekte, die FastOpenAPI nutzen?","text":"<p>A: Im Verzeichnis <code>examples/</code> des Repos findest du Beispielprojekte f\u00fcr jedes unterst\u00fctzte Framework. Wenn du FastOpenAPI produktiv einsetzt, freuen wir uns \u00fcber Links oder Erfahrungsberichte!</p>"},{"location":"faq/#f-welche-openapi-version-wird-generiert","title":"F: Welche OpenAPI-Version wird generiert?","text":"<p>A: FastOpenAPI generiert OpenAPI 3.1.0, da Pydantic v2 JSON Schema in diesem Format ausgibt. Swagger UI und ReDoc unterst\u00fctzen diese Version.</p> <p>Wenn du weitere Fragen hast, schau auch in die Abschnitte Usage, Advanced oder ins GitHub-Issue-Tracking. Deine Fragen helfen, das Projekt zu verbessern!</p>"},{"location":"advanced/advanced_usage/","title":"Erweiterte Nutzung","text":"<p>In diesem Abschnitt behandeln wir fortgeschrittene Themen wie die Architektur von FastOpenAPI, die Erweiterung auf neue Frameworks und die Anpassung des generierten Verhaltens oder der Dokumentation. Diese Informationen richten sich an Entwickler:innen, die FastOpenAPI tiefer verstehen, anpassen oder in nicht-standardisierte Umgebungen integrieren m\u00f6chten.</p>"},{"location":"advanced/advanced_usage/#architekturuberblick","title":"Architektur\u00fcberblick","text":"<p>Das Design von FastOpenAPI ist von FastAPI inspiriert, aber framework-unabh\u00e4ngig aufgebaut. Die Hauptkomponenten sind:</p> <ul> <li>BaseRouter: Die zentrale Basisklasse, welche Routing, OpenAPI-Schema-Generierung und Verarbeitung von Requests/Responses kapselt. Sie ist nicht an ein spezifisches Framework gebunden.</li> <li>Framework-spezifische Router: Subklassen von <code>BaseRouter</code>, z.\u202fB. <code>FlaskRouter</code>, <code>StarletteRouter</code> usw., die die Integration mit konkreten Frameworks \u00fcbernehmen.</li> <li>Pydantic-Modelle: FastOpenAPI nutzt Pydantic zur Definition, Validierung und Dokumentation von Datenstrukturen.</li> <li>OpenAPI-Generierung: FastOpenAPI erstellt auf Basis von Metadaten (Routen, Parameter, Modelle) automatisch ein vollst\u00e4ndiges OpenAPI-3.1-Schema. Dieses ist unter <code>/openapi.json</code> abrufbar.</li> <li>Dokumentationsrouten: \u00dcber <code>/docs</code> (Swagger UI) und <code>/redoc</code> (ReDoc) stehen interaktive Dokumentationen zur Verf\u00fcgung.</li> </ul>"},{"location":"advanced/advanced_usage/#ablauf-eines-requests","title":"Ablauf eines Requests","text":"<ol> <li>Eine Anfrage trifft auf die Route einer Anwendung (z.\u202fB. in Flask), die mit FastOpenAPI registriert wurde.</li> <li>Der Dekorator <code>@router.get/post/...</code> hat die Funktion registriert.</li> <li>Vor dem Funktionsaufruf f\u00fchrt FastOpenAPI:</li> <li>Extraktion von Pfadparametern (meist durch das Framework selbst),</li> <li>Validierung von Query-/Header-/Body-Parametern (via Pydantic),</li> <li>Fehlerbehandlung bei ung\u00fcltigen Eingaben durch.</li> <li>Die Funktion wird mit validierten Parametern aufgerufen.</li> <li>Die Antwort wird je nach <code>response_model</code> serialisiert (validiert und in JSON umgewandelt).</li> <li>Im Fehlerfall (z.\u202fB. <code>ResourceNotFoundError</code>) wird eine JSON-Fehlermeldung erzeugt.</li> <li>Die Antwort wird durch das Framework zur\u00fcckgegeben.</li> </ol>"},{"location":"advanced/advanced_usage/#erweiterung-auf-weitere-frameworks","title":"Erweiterung auf weitere Frameworks","text":"<p>FastOpenAPI ist modular konzipiert. Wenn dein Framework nicht unterst\u00fctzt wird, kannst du eine eigene Integration schreiben.</p>"},{"location":"advanced/advanced_usage/#vorgehen","title":"Vorgehen:","text":"<ul> <li>Erstelle eine neue Klasse, die <code>BaseRouter</code> erweitert.</li> <li>Implementiere:</li> <li>Registrierung von Routen (z.\u202fB. <code>add_route()</code>),</li> <li>(Optional) Startlogik der App,</li> <li>Einbindung von <code>/docs</code>, <code>/redoc</code>, <code>/openapi.json</code>.</li> </ul>"},{"location":"advanced/advanced_usage/#hinweise","title":"Hinweise:","text":"<ul> <li>Bestehende Implementierungen wie <code>FlaskRouter</code>, <code>StarletteRouter</code> etc. dienen als gute Vorlage.</li> <li>Methoden wie <code>get_openapi_schema()</code> in <code>BaseRouter</code> sind wiederverwendbar.</li> </ul>"},{"location":"advanced/advanced_usage/#beispiel-eigener-router","title":"Beispiel: Eigener Router","text":"<p>Wenn du z.\u202fB. einen <code>MyCustomFrameworkRouter</code> erstellen willst:</p> <pre><code>from fastopenapi.base_router import BaseRouter\n\nclass MyCustomRouter(BaseRouter):\n    def add_route(self, path, method, handler):\n        # Framework-spezifische Logik\n        pass\n</code></pre> <p>Du kannst bestehende Methoden \u00fcberschreiben oder Hooks hinzuf\u00fcgen.</p>"},{"location":"advanced/api_reference/","title":"API-Referenz","text":"<p>In diesem Abschnitt findest du eine detaillierte Referenz zu den Klassen und Modulen von FastOpenAPI, inklusive Schnittstellen, Methoden und konkreter Anwendungsbeispiele.</p>"},{"location":"advanced/api_reference/#projektstruktur","title":"Projektstruktur","text":"<p>FastOpenAPI verwendet eine modulare Architektur:</p> <pre><code>fastopenapi/\n\u251c\u2500\u2500 base_router.py\n\u2514\u2500\u2500 routers/\n    \u251c\u2500\u2500 aiohttp.py\n    \u251c\u2500\u2500 falcon.py\n    \u251c\u2500\u2500 flask.py\n    \u251c\u2500\u2500 quart.py\n    \u251c\u2500\u2500 sanic.py\n    \u251c\u2500\u2500 starlette.py\n    \u2514\u2500\u2500 tornado.py\n</code></pre>"},{"location":"advanced/api_reference/#baserouter","title":"BaseRouter","text":"<p>Beschreibung: Abstrakte Basisklasse, die Routing-Logik, OpenAPI-Schema-Generierung und Validierungsverhalten kapselt. Wird von den Framework-spezifischen Routern geerbt.</p>"},{"location":"advanced/api_reference/#wichtige-methoden","title":"Wichtige Methoden","text":"<ul> <li><code>__init__(...)</code></li> <li><code>get(path, **options)</code>: Registriert einen GET-Endpunkt.</li> <li><code>post(path, **options)</code>: Registriert einen POST-Endpunkt.</li> <li><code>put(path, **options)</code>: Registriert einen PUT-Endpunkt.</li> <li><code>patch(path, **options)</code>: Registriert einen PATCH-Endpunkt.</li> <li><code>delete(path, **options)</code>: Registriert einen DELETE-Endpunkt.</li> <li><code>include_router(other_router, prefix=\"\")</code>: Erm\u00f6glicht das Einbinden anderer Router unter einem Pr\u00e4fix.</li> <li><code>generate_openapi_schema()</code>: Erzeugt das OpenAPI-Schema.</li> </ul>"},{"location":"advanced/api_reference/#attribute","title":"Attribute","text":"<ul> <li><code>app</code>: Das verbundene Framework-Objekt.</li> <li><code>docs_url</code>, <code>redoc_url</code>, <code>openapi_url</code>: Endpunkte f\u00fcr die Dokumentation.</li> <li><code>title</code>, <code>description</code>, <code>version</code>: Metadaten f\u00fcr die OpenAPI-Dokumentation.</li> </ul>"},{"location":"advanced/api_reference/#framework-router","title":"Framework-Router","text":"<p>Jedes unterst\u00fctzte Framework hat einen eigenen Router, der von <code>BaseRouter</code> erbt:</p>"},{"location":"advanced/api_reference/#aiohttprouter","title":"AioHttpRouter","text":"<pre><code>from aiohttp import web\nfrom fastopenapi.routers import AioHttpRouter\n\napp = web.Application()\nrouter = AioHttpRouter(app=app)\n\n@router.get(\"/status\")\nasync def status():\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"advanced/api_reference/#falconrouter","title":"FalconRouter","text":"<pre><code>import falcon.asgi\nfrom fastopenapi.routers import FalconRouter\n\napp = falcon.asgi.App()\nrouter = FalconRouter(app=app)\n\n@router.get(\"/status\")\nasync def status():\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"advanced/api_reference/#flaskrouter","title":"FlaskRouter","text":"<pre><code>from flask import Flask\nfrom fastopenapi.routers import FlaskRouter\n\napp = Flask(__name__)\nrouter = FlaskRouter(app=app)\n\n@router.get(\"/hello\")\ndef hello(name: str):\n    return {\"message\": f\"Hello {name}\"}\n</code></pre>"},{"location":"advanced/api_reference/#quartrouter","title":"QuartRouter","text":"<pre><code>from quart import Quart\nfrom fastopenapi.routers import QuartRouter\n\napp = Quart(__name__)\nrouter = QuartRouter(app=app)\n\n@router.get(\"/ping\")\nasync def ping():\n    return {\"pong\": True}\n</code></pre>"},{"location":"advanced/api_reference/#sanicrouter","title":"SanicRouter","text":"<pre><code>from sanic import Sanic\nfrom fastopenapi.routers import SanicRouter\n\napp = Sanic(\"MySanicApp\")\nrouter = SanicRouter(app=app)\n\n@router.get(\"/info\")\nasync def info():\n    return {\"framework\": \"Sanic\", \"status\": \"running\"}\n</code></pre>"},{"location":"advanced/api_reference/#starletterouter","title":"StarletteRouter","text":"<p>Use for Starlette integration.</p> <pre><code>from starlette.applications import Starlette\nfrom fastopenapi.routers import StarletteRouter\n\napp = Starlette()\nrouter = StarletteRouter(app=app)\n\n@router.get(\"/check\")\nasync def check():\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"advanced/api_reference/#tornadorouter","title":"TornadoRouter","text":"<p>Use for Tornado integration.</p> <pre><code>from tornado.web import Application\nfrom fastopenapi.routers import TornadoRouter\n\napp = Application()\nrouter = TornadoRouter(app=app)\n\n@router.get(\"/status\")\ndef status():\n    return {\"running\": True}\n</code></pre>"},{"location":"advanced/api_reference/#subrouter-verwenden","title":"Subrouter verwenden","text":"<p>Du kannst Routen modular strukturieren:</p> <pre><code>api_v1 = &lt;Framework&gt;Router()\n\n@api_v1.get(\"/users\")\ndef users():\n    return [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n\nmain_router = &lt;Framework&gt;Router(app=app)\nmain_router.include_router(api_v1, prefix=\"/v1\")\n</code></pre>"},{"location":"advanced/api_reference/#fehlerbehandlung","title":"Fehlerbehandlung","text":""},{"location":"advanced/api_reference/#bibliotheksinterne-fehlerklassen","title":"Bibliotheksinterne Fehlerklassen","text":"<pre><code>from fastopenapi.error_handler import BadRequestError, ResourceNotFoundError\n\n@router.get(\"/validate\")\ndef validate_input(param: int):\n    if param &lt; 0:\n        raise BadRequestError(\"Parameter muss positiv sein\")\n\n@router.get(\"/items/{item_id}\")\ndef get_item(item_id: int):\n    item = db.get(item_id)\n    if item is None:\n        raise ResourceNotFoundError(f\"Item {item_id} nicht gefunden\")\n</code></pre>"},{"location":"advanced/api_reference/#fehlerbehandlung-je-framework","title":"Fehlerbehandlung je Framework","text":"<p>FastOpenAPI unterst\u00fctzt auch Framework-eigene Fehler:</p>"},{"location":"advanced/api_reference/#aiohttp","title":"AioHTTP","text":"<pre><code>from aiohttp import web\n\n@router.get(\"/notfound\")\ndef aiohttp_notfound():\n    raise web.HTTPNotFound(reason=\"Not Found\")\n</code></pre>"},{"location":"advanced/api_reference/#falcon","title":"Falcon","text":"<pre><code>import falcon\n\n@router.get(\"/notfound\")\nasync def falcon_notfound():\n    raise falcon.HTTPNotFound(title=\"Not Found\", description=\"Falcon error\")\n</code></pre>"},{"location":"advanced/api_reference/#flask","title":"Flask","text":"<pre><code>from flask import abort\n\n@router.get(\"/notfound\")\ndef flask_notfound():\n    abort(404, description=\"Flask error\")\n</code></pre>"},{"location":"advanced/api_reference/#quart","title":"Quart","text":"<pre><code>from quart import abort\n\n@router.get(\"/notfound\")\nasync def quart_notfound():\n    abort(404, description=\"Quart error\")\n</code></pre>"},{"location":"advanced/api_reference/#sanic","title":"Sanic","text":"<pre><code>from sanic import NotFound\n\n@router.get(\"/notfound\")\nasync def sanic_notfound():\n    raise NotFound()\n</code></pre>"},{"location":"advanced/api_reference/#starlette","title":"Starlette","text":"<pre><code>from starlette.exceptions import HTTPException\n\n@router.get(\"/notfound\")\nasync def starlette_notfound():\n    raise HTTPException(status_code=404, detail=\"Not Found\")\n</code></pre>"},{"location":"advanced/api_reference/#tornado","title":"Tornado","text":"<pre><code>from tornado.web import HTTPError\n\n@router.get(\"/notfound\")\nasync def tornado_notfound():\n    raise HTTPError(status_code=404, reason=\"Not Found\")\n</code></pre>"},{"location":"frameworks/aiohttp/","title":"AIOHTTP-Integration","text":"<p>Dieses Kapitel zeigt, wie man FastOpenAPI mit AIOHTTP verwendet (ein asynchrones HTTP-Framework f\u00fcr Python).</p> <p>AIOHTTP-Anwendungen basieren auf <code>aiohttp.web.Application</code> und werden mit <code>aiohttp.web.run_app</code> ausgef\u00fchrt. FastOpenAPI stellt den <code>AioHttpRouter</code> zur Integration bereit.</p>"},{"location":"frameworks/aiohttp/#installation","title":"Installation","text":"<p>Stelle sicher, dass FastOpenAPI installiert ist:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>oder:</p> <pre><code>pip install fastopenapi[aiohttp]\n</code></pre>"},{"location":"frameworks/aiohttp/#hello-world","title":"Hello World","text":"<pre><code>from aiohttp import web\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import AioHttpRouter\n\napp = web.Application()\nrouter = AioHttpRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Sag Hallo mit AIOHTTP\"\"\"\n    return HelloResponse(message=f\"Hallo, {name}! Hier ist aiohttp!\")\n\nif __name__ == \"__main__\":\n    web.run_app(app, host=\"127.0.0.1\", port=8000)\n</code></pre>"},{"location":"frameworks/aiohttp/#beispielprojekt","title":"Beispielprojekt","text":"<p>Ein vollst\u00e4ndiges Beispiel findest du im Verzeichnis <code>examples/aiohttp/</code> des Repositories.</p>"},{"location":"frameworks/falcon/","title":"Falcon-Integration","text":"<p>In diesem Leitfaden wird die Verwendung von FastOpenAPI mit Falcon beschrieben, einem leistungsstarken Webframework.</p> <p>FastOpenAPI unterst\u00fctzt Falcon \u00fcber den <code>FalconRouter</code>, insbesondere bei Verwendung der ASGI-Schnittstelle f\u00fcr asynchrone Anwendungen.</p>"},{"location":"frameworks/falcon/#installation","title":"Installation","text":"<p>FastOpenAPI installieren:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>oder:</p> <pre><code>pip install fastopenapi[falcon]\n</code></pre>"},{"location":"frameworks/falcon/#hello-world","title":"Hello World","text":"<pre><code>import falcon.asgi\nimport uvicorn\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import FalconRouter\n\napp = falcon.asgi.App()           # ASGI-Anwendung (async-f\u00e4hig)\nrouter = FalconRouter(app=app)    # FastOpenAPI-Router einbinden\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Sag Hallo mit Falcon\"\"\"\n    return HelloResponse(message=f\"Hallo, {name}! Hier ist Falcon!\")\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n</code></pre>"},{"location":"frameworks/falcon/#beispielprojekt","title":"Beispielprojekt","text":"<p>Ein vollst\u00e4ndiges Beispiel findest du im Verzeichnis <code>examples/falcon/</code> des Repositories.</p>"},{"location":"frameworks/flask/","title":"Flask-Integration","text":"<p>Dieser Leitfaden zeigt die Integration von FastOpenAPI mit Flask, einem der beliebtesten Python-Webframeworks.</p> <p>Die Klasse <code>FlaskRouter</code> verbindet FastOpenAPI mit dem Routing-System von Flask.</p>"},{"location":"frameworks/flask/#installation","title":"Installation","text":"<p>FastOpenAPI installieren:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>oder</p> <pre><code>pip install fastopenapi[flask]\n</code></pre>"},{"location":"frameworks/flask/#hello-world","title":"Hello World","text":"<pre><code>from flask import Flask\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import FlaskRouter\n\napp = Flask(__name__)\nrouter = FlaskRouter(app=app)  # FastOpenAPI-Router einbinden\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Sag Hallo mit Flask\"\"\"\n    return HelloResponse(message=f\"Hallo, {name}! Hier ist Flask!\")\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre>"},{"location":"frameworks/flask/#beispielprojekt","title":"Beispielprojekt","text":"<p>Ein vollst\u00e4ndiges Beispiel findest du im Verzeichnis <code>examples/flask/</code> des Repositories.</p>"},{"location":"frameworks/quart/","title":"Quart-Integration","text":"<p>Quart ist ein asynchrones Webframework mit einer API, die Flask sehr \u00e4hnlich ist (quasi ein Ersatz mit async-Unterst\u00fctzung).</p> <p>FastOpenAPI bietet mit <code>QuartRouter</code> eine Integration speziell f\u00fcr Quart.</p>"},{"location":"frameworks/quart/#installation","title":"Installation","text":"<p>FastOpenAPI installieren:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>oder</p> <pre><code>pip install fastopenapi[quart]\n</code></pre>"},{"location":"frameworks/quart/#hello-world","title":"Hello World","text":"<pre><code>from quart import Quart\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import QuartRouter\n\napp = Quart(__name__)\nrouter = QuartRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Sag Hallo mit Quart\"\"\"\n    return HelloResponse(message=f\"Hallo, {name}! Hier ist Quart!\")\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre>"},{"location":"frameworks/quart/#beispielprojekt","title":"Beispielprojekt","text":"<p>Ein vollst\u00e4ndiges Beispiel findest du im Verzeichnis <code>examples/quart/</code> des Repositories.</p>"},{"location":"frameworks/sanic/","title":"Sanic-Integration","text":"<p>Sanic ist ein asynchrones Webframework, das f\u00fcr seine Geschwindigkeit bekannt ist.</p> <p>FastOpenAPI integriert sich in Sanic \u00fcber den <code>SanicRouter</code>.</p>"},{"location":"frameworks/sanic/#installation","title":"Installation","text":"<p>FastOpenAPI installieren:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>oder</p> <pre><code>pip install fastopenapi[sanic]\n</code></pre>"},{"location":"frameworks/sanic/#hello-world","title":"Hello World","text":"<pre><code>from sanic import Sanic\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import SanicRouter\n\napp = Sanic(\"MySanicApp\")\nrouter = SanicRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Sag Hallo mit Sanic\"\"\"\n    return HelloResponse(message=f\"Hallo, {name}! Hier ist Sanic!\")\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"frameworks/sanic/#beispielprojekt","title":"Beispielprojekt","text":"<p>Ein vollst\u00e4ndiges Beispiel findest du im Verzeichnis <code>examples/sanic/</code> des Repositories.</p>"},{"location":"frameworks/starlette/","title":"Starlette-Integration","text":"<p>Starlette ist ein leichtgewichtiges ASGI-Framework, auf dem auch FastAPI selbst basiert.</p> <p>FastOpenAPI bietet mit <code>StarletteRouter</code> eine direkte Integration in Starlette-Anwendungen.</p>"},{"location":"frameworks/starlette/#installation","title":"Installation","text":"<p>FastOpenAPI installieren:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>oder</p> <pre><code>pip install fastopenapi[starlette]\n</code></pre>"},{"location":"frameworks/starlette/#hello-world","title":"Hello World","text":"<pre><code>import uvicorn\nfrom pydantic import BaseModel\nfrom starlette.applications import Starlette\nfrom fastopenapi.routers import StarletteRouter\n\napp = Starlette()\nrouter = StarletteRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Sag Hallo mit Starlette\"\"\"\n    return HelloResponse(message=f\"Hallo, {name}! Hier ist Starlette!\")\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n</code></pre>"},{"location":"frameworks/starlette/#beispielprojekt","title":"Beispielprojekt","text":"<p>Ein vollst\u00e4ndiges Beispiel findest du im Verzeichnis <code>examples/starlette/</code> des Repositories.</p>"},{"location":"frameworks/tornado/","title":"Tornado-Integration","text":"<p>Tornado ist ein etabliertes Webframework und eine asynchrone Netzwerkbibliothek f\u00fcr Python.</p> <p>FastOpenAPI unterst\u00fctzt Tornado \u00fcber den <code>TornadoRouter</code>, mit dem du OpenAPI-Dokumentation zu Tornado-Anwendungen hinzuf\u00fcgen kannst.</p>"},{"location":"frameworks/tornado/#installation","title":"Installation","text":"<p>FastOpenAPI installieren:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>oder</p> <pre><code>pip install fastopenapi[tornado]\n</code></pre>"},{"location":"frameworks/tornado/#hello-world","title":"Hello World","text":"<pre><code>import asyncio\nfrom pydantic import BaseModel\nfrom tornado.web import Application\nfrom fastopenapi.routers import TornadoRouter\n\napp = Application()\nrouter = TornadoRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Sag Hallo mit Tornado\"\"\"\n    return HelloResponse(message=f\"Hallo, {name}! Hier ist Tornado!\")\n\nasync def main():\n    app.listen(8000)\n    await asyncio.Event().wait()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"frameworks/tornado/#beispielprojekt","title":"Beispielprojekt","text":"<p>Ein vollst\u00e4ndiges Beispiel findest du im Verzeichnis <code>examples/tornado/</code> des Repositories.</p>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>FastOpenAPI ist auf PyPI verf\u00fcgbar und unterst\u00fctzt Python 3.10+. Du kannst entweder nur die Kernbibliothek oder optionale Abh\u00e4ngigkeiten f\u00fcr bestimmte Webframeworks installieren.</p>"},{"location":"getting_started/installation/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li>Python 3.10 oder h\u00f6her \u2013 erforderlich wegen moderner Typisierung und Unterst\u00fctzung f\u00fcr Pydantic v2.</li> <li>(Optional) Ein bestehendes Webframework (wie Flask, Starlette usw.), falls du eines integrieren m\u00f6chtest. Falls noch nicht installiert, kannst du es \u00fcber die entsprechenden Extras automatisch mitinstallieren.</li> </ul>"},{"location":"getting_started/installation/#installation-via-pip","title":"Installation via pip","text":""},{"location":"getting_started/installation/#nur-fastopenapi-installieren","title":"Nur FastOpenAPI installieren","text":"<p>Standardinstallation</p> <pre><code>pip install fastopenapi\n</code></pre>"},{"location":"getting_started/installation/#fastopenapi-mit-spezifischem-framework-installieren","title":"FastOpenAPI mit spezifischem Framework installieren","text":"<p>N\u00fctzlich f\u00fcr neue Projekte ohne vorinstalliertes Framework</p> <pre><code>pip install fastopenapi[aiohttp]\n</code></pre> <pre><code>pip install fastopenapi[falcon]\n</code></pre> <pre><code>pip install fastopenapi[flask]\n</code></pre> <pre><code>pip install fastopenapi[quart]\n</code></pre> <pre><code>pip install fastopenapi[sanic]\n</code></pre> <pre><code>pip install fastopenapi[starlette]\n</code></pre> <pre><code>pip install fastopenapi[tornado]\n</code></pre>"},{"location":"getting_started/quickstart/","title":"Schnellstart","text":"<p>Dieses Schnellstart-Tutorial zeigt dir, wie du FastOpenAPI zu einer einfachen Anwendung hinzuf\u00fcgst und die generierte API-Dokumentation anzeigen kannst.</p>"},{"location":"getting_started/quickstart/#schritt-0-bibliothek-installieren","title":"Schritt 0. Bibliothek installieren","text":"<p>Folge den Anweisungen unter Installation</p>"},{"location":"getting_started/quickstart/#schritt-1-anwendung-erstellen","title":"Schritt 1. Anwendung erstellen","text":"<ul> <li>Erstelle eine Datei <code>main.py</code></li> <li>Kopiere den Code aus einem Beispiel</li> <li>F\u00fcr einige Beispiele ist uvicorn erforderlich (<code>pip install uvicorn</code>)</li> </ul>"},{"location":"getting_started/quickstart/#beispiele","title":"Beispiele","text":""},{"location":"getting_started/quickstart/#aiohttp","title":"AioHTTP","text":"Click to expand the AioHttp Example <pre><code>from aiohttp import web\nfrom pydantic import BaseModel\n\nfrom fastopenapi.routers import AioHttpRouter\n\napp = web.Application()\nrouter = AioHttpRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from aiohttp\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's aiohttp!\")\n\n\nif __name__ == \"__main__\":\n    web.run_app(app, host=\"127.0.0.1\", port=8000)\n</code></pre>"},{"location":"getting_started/quickstart/#falcon","title":"Falcon","text":"Click to expand the Falcon Example <pre><code>import falcon.asgi\nimport uvicorn\nfrom pydantic import BaseModel\n\nfrom fastopenapi.routers import FalconRouter\n\napp = falcon.asgi.App()\nrouter = FalconRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Falcon\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Falcon!\")\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#flask","title":"Flask","text":"Click to expand the Flask Example <pre><code>from flask import Flask\nfrom pydantic import BaseModel\n\nfrom fastopenapi.routers import FlaskRouter\n\napp = Flask(__name__)\nrouter = FlaskRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Say hello from Flask\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Flask!\")\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#quart","title":"Quart","text":"Click to expand the Quart Example <pre><code>from pydantic import BaseModel\nfrom quart import Quart\n\nfrom fastopenapi.routers import QuartRouter\n\napp = Quart(__name__)\nrouter = QuartRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Quart\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Quart!\")\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#sanic","title":"Sanic","text":"Click to expand the Sanic Example <pre><code>from pydantic import BaseModel\nfrom sanic import Sanic\n\nfrom fastopenapi.routers import SanicRouter\n\napp = Sanic(\"MySanicApp\")\nrouter = SanicRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Sanic\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Sanic!\")\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#starlette","title":"Starlette","text":"Click to expand the Starlette Example <pre><code>import uvicorn\nfrom pydantic import BaseModel\nfrom starlette.applications import Starlette\n\nfrom fastopenapi.routers import StarletteRouter\n\napp = Starlette()\nrouter = StarletteRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Starlette\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Starlette!\")\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#tornado","title":"Tornado","text":"Click to expand the Tornado Example <pre><code>import asyncio\nfrom pydantic import BaseModel\nfrom tornado.web import Application\nfrom fastopenapi.routers.tornado import TornadoRouter\n\napp = Application()\nrouter = TornadoRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Say hello from Tornado\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Tornado!\")\n\nasync def main():\n    app.listen(8000)\n    await asyncio.Event().wait()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n</code></pre>"},{"location":"getting_started/quickstart/#schritt-2-server-starten","title":"Schritt 2. Server starten","text":"<pre><code>python main.py\n</code></pre> <p>Nach dem Start ist die Dokumentation erreichbar unter:</p>"},{"location":"getting_started/quickstart/#swagger-ui","title":"Swagger UI","text":"<pre><code>http://127.0.0.1:8000/docs\n</code></pre> <p>Interaktive API-Dokumentation mit Swagger UI:</p> <p></p>"},{"location":"getting_started/quickstart/#redoc","title":"ReDoc","text":"<pre><code>http://127.0.0.1:8000/redoc\n</code></pre> <p>Alternative Dokumentation mit ReDoc:</p> <p></p>"},{"location":"getting_started/quickstart/#generierte-endpunkte","title":"Generierte Endpunkte","text":"<p>Nach dem Start sind diese Endpunkte verf\u00fcgbar:</p> <ul> <li>Swagger UI: http://localhost:8000/docs</li> <li>ReDoc: http://localhost:8000/redoc</li> <li>OpenAPI JSON: http://localhost:8000/openapi.json</li> </ul>"},{"location":"getting_started/usage/","title":"Verwendung","text":"<p>In diesem Abschnitt wird erkl\u00e4rt, wie FastOpenAPI genutzt wird, um API-Endpunkte zu dokumentieren und Eingaben/Ausgaben zu validieren. Es folgen Beispiele f\u00fcr verschiedene Anwendungsszenarien, inklusive Fehlerbehandlung durch die Bibliothek und durch das zugrundeliegende Framework.</p>"},{"location":"getting_started/usage/#definition-von-endpunkten","title":"Definition von Endpunkten","text":""},{"location":"getting_started/usage/#verfugbare-methoden","title":"Verf\u00fcgbare Methoden","text":"<ul> <li><code>@router.get(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.post(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.patch(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.put(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.delete(path, response_errors, response_model, tags, status_code)</code></li> </ul>"},{"location":"getting_started/usage/#kurzbeschreibung","title":"Kurzbeschreibung","text":"<ul> <li><code>path</code> \u2013 die URL des Endpunkts.</li> <li><code>response_errors</code> \u2013 Liste m\u00f6glicher Fehlerstatuscodes f\u00fcr die OpenAPI-Spezifikation.</li> <li><code>response_model</code> \u2013 Pydantic-Modell oder einfacher Python-Typ f\u00fcr das Antwortschema.</li> <li><code>tags</code> \u2013 OpenAPI-Tags zur Gruppierung.</li> <li><code>status_code</code> \u2013 HTTP-Statuscode bei erfolgreicher Antwort.</li> </ul>"},{"location":"getting_started/usage/#beispiel","title":"Beispiel","text":"<pre><code>from pydantic import BaseModel\nfrom typing import Optional\n\n# Don't use this router. It's just an example.\nfrom fastopenapi.base_router import BaseRouter\n\nclass CreateUserRequest(BaseModel):\n    name: str\n    surname: str\n    age: int\n\nclass UpdateUserRequest(BaseModel):\n    name: Optional[str]\n    surname: Optional[str]\n    age: Optional[int]\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    surname: str\n    age: int\n\nrouter = BaseRouter()\n\n@router.get(\"/user/{user_id}\", tags=[\"User\"], status_code=200, response_model=UserResponse)\ndef get_user(user_id: int):\n    data = {}\n    return UserResponse(**data)\n\n@router.post(\"/user\", tags=[\"User\"], status_code=201, response_model=UserResponse)\ndef create_user(user_data: CreateUserRequest):\n    data = {}\n    return UserResponse(**data)\n\n@router.patch(\"/user/{user_id}\", tags=[\"User\"], status_code=200, response_model=UserResponse)\ndef update_user(user_id: int, user_data: UpdateUserRequest):\n    data = {}\n    return UserResponse(**data)\n\n@router.delete(\"/user/{user_id}\", tags=[\"User\"], status_code=204)\ndef delete_user(user_id: int):\n    return None\n</code></pre>"},{"location":"getting_started/usage/#einfacher-get-endpunkt","title":"Einfacher GET-Endpunkt","text":"<pre><code>@router.get(\"/items\")\nasync def list_items():\n    return {\"items\": [\"foo\", \"bar\"]}\n</code></pre>"},{"location":"getting_started/usage/#pfadparameter","title":"Pfadparameter","text":"<pre><code>@router.get(\"/items/{item_id}\")\nasync def get_item(item_id: int):\n    item = database.get(item_id)\n    if item is None:\n        raise ResourceNotFoundError(f\"Item {item_id} nicht gefunden\")\n    return item\n</code></pre>"},{"location":"getting_started/usage/#query-parameter","title":"Query-Parameter","text":"<pre><code>@router.get(\"/search\")\nasync def search(q: str = \"\", limit: int = 10):\n    if limit &lt; 0:\n        raise BadRequestError(\"Limit darf nicht negativ sein\")\n    return {\"query\": q, \"limit\": limit}\n</code></pre>"},{"location":"getting_started/usage/#anfragekorper-mit-pydantic-validieren","title":"Anfragek\u00f6rper mit Pydantic validieren","text":"<pre><code>from flask import abort\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n@router.post(\"/items\", response_model=Item, status_code=201)\ndef create_item(item: Item):\n    try:\n        save_to_database(item)\n    except DatabaseError:\n        abort(500, description=\"Datenbankfehler\")\n    return item\n</code></pre>"},{"location":"getting_started/usage/#router-aufteilen-mit-subroutern","title":"Router aufteilen mit Subroutern","text":"<p>Datei: users.py</p> <pre><code>from fastopenapi.routers import StarletteRouter\nfrom pydantic import BaseModel\nfrom typing import List\n\nuser_router = StarletteRouter()\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n@user_router.get(\"/users\", response_model=List[User])\nasync def list_users():\n    return [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\n\n@user_router.post(\"/users\", response_model=User, status_code=201)\nasync def create_user(user: User):\n    save_user_to_database(user)\n    return user\n</code></pre> <p>Datei: main.py</p> <pre><code>from fastopenapi.routers import StarletteRouter\nfrom starlette.applications import Starlette\nfrom users import user_router\n\napp = Starlette()\nmain_router = StarletteRouter(app=app)\nmain_router.include_router(user_router, prefix=\"/v1\")\n</code></pre>"},{"location":"getting_started/usage/#fehlerbehandlung","title":"Fehlerbehandlung","text":""},{"location":"getting_started/usage/#bibliothekseigene-fehler","title":"Bibliothekseigene Fehler","text":"<pre><code>from fastopenapi.error_handler import ResourceNotFoundError\n\n@router.get(\"/products/{product_id}\")\nasync def get_product(product_id: int):\n    product = database.get_product(product_id)\n    if product is None:\n        raise ResourceNotFoundError(f\"Produkt {product_id} nicht gefunden\")\n    return product\n</code></pre>"},{"location":"getting_started/usage/#framework-fehler","title":"Framework-Fehler","text":""},{"location":"getting_started/usage/#flask","title":"Flask","text":"<pre><code>from flask import abort\n\n@router.get(\"/orders/{order_id}\")\ndef get_order(order_id: int):\n    order = get_order_from_db(order_id)\n    if order is None:\n        abort(404, description=\"Bestellung nicht gefunden\")\n    return order\n</code></pre>"},{"location":"getting_started/usage/#falcon","title":"Falcon","text":"<pre><code>import falcon\n\n@router.get(\"/invoices/{invoice_id}\")\nasync def get_invoice(invoice_id: int):\n    invoice = database.get_invoice(invoice_id)\n    if invoice is None:\n        raise falcon.HTTPNotFound(title=\"Nicht gefunden\", description=\"Rechnung nicht gefunden\")\n    return invoice\n</code></pre> <p>Diese Beispiele zeigen, wie man:</p> <ul> <li>Pfad-, Query- und Body-Parameter definiert,</li> <li>Pydantic zur Validierung und OpenAPI-Generierung nutzt,</li> <li>Fehler \u00fcber Ausnahmen behandelt (sowohl mitgeliefert als auch framework-spezifisch).</li> </ul>"},{"location":"getting_started/usage/#projektbeispiele","title":"Projektbeispiele","text":"<p>Siehe das Verzeichnis <code>examples/</code> im Repository f\u00fcr vollst\u00e4ndige Beispiele je Framework.</p>"}]}
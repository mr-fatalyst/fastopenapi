{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastOpenAPI","text":"<p> FastOpenAPI is a library for generating and integrating OpenAPI schemas using Pydantic and various frameworks. </p> <p>   This project was inspired by FastAPI and aims to provide a similar developer-friendly experience. </p> <p> </p>"},{"location":"#about","title":"About","text":"<p>FastOpenAPI is a Python library for seamlessly generating and integrating OpenAPI schemas using Pydantic models across multiple web frameworks. Inspired by FastAPI, it aims to provide a similar developer-friendly experience for frameworks like AIOHTTP, Falcon, Flask, Quart, Sanic, Starlette, and Tornado. With FastOpenAPI, you can add interactive API documentation and request/response validation to your existing web application without switching frameworks.</p> <p>FastOpenAPI is currently in active development (pre-1.0). While it's already usable, expect potential breaking changes as the project evolves. We welcome feedback and contributions to improve stability and add new features.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Auto-generated OpenAPI schemas \u2013 Define your API routes and data models, and FastOpenAPI will automatically generate a complete OpenAPI (Swagger) schema.</li> <li>Pydantic v2 support \u2013 Leverage Pydantic models for data validation and serialization. Both request payloads and responses can be validated with Pydantic, ensuring correct data types.</li> <li>Multi-framework integration \u2013 Includes out-of-the-box support for AIOHTTP, Falcon, Flask, Quart, Sanic, Starlette, and Tornado. This lets you use FastOpenAPI with your preferred web framework seamlessly.</li> <li>FastAPI-style routing \u2013 Use decorator-based routing (e.g. <code>@router.get</code>, <code>@router.post</code>) similar to FastAPI\u2019s <code>APIRouter</code>. This proxy routing provides a familiar interface for defining endpoints and automatically ties into the framework\u2019s routing.</li> <li>Interactive docs UIs \u2013 Automatically serves Swagger UI at <code>/docs</code> and ReDoc at <code>/redoc</code> in your application for interactive API exploration and documentation.</li> <li>Request validation and error handling \u2013 Invalid inputs are caught and returned as HTTP errors with JSON error messages. Custom exception classes are provided for common API errors (400 Bad Request, 404 Not Found, etc.) to simplify error handling.</li> </ul> <p>Use the navigation to explore the documentation. Start with Installation and Quickstart to get FastOpenAPI up and running, then see Usage for deeper examples. Framework-specific guides provide instructions for each supported framework. For advanced topics (like extending FastOpenAPI or understanding its architecture), check out Advanced Usage and the API Reference. If you want to contribute or see what\u2019s changed in each release, see the Contributing and Changelog sections. Finally, our FAQ addresses common questions.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to FastOpenAPI will be documented in this file.</p>"},{"location":"changelog/#070-2025-04-27","title":"[0.7.0] - 2025-04-27","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Replaced <code>json.dumps/json.loads</code> with pydantic_core <code>to_json/from_json</code></li> <li><code>_serialize_response</code>: model list mapping now handled by Pydantic instead of manual recursion</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Issue with parsing repeated query parameters in URL.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>The <code>use_aliases</code> from <code>BaseRouter</code> and reverted changes from 0.6.0.</li> </ul>"},{"location":"changelog/#060-20250416","title":"[0.6.0] \u2013 2025\u201104\u201116","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>The <code>use_aliases</code> parameter was added to the <code>BaseRouter</code> constructor. Default is <code>True</code>. To preserve the previous behavior (without using aliases from Pydantic), set <code>use_aliases=False</code>. </li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>The <code>_serialize_response method</code> is now an instance method (was a <code>@staticmethod</code>) \u2014 to support <code>use_aliases</code>.</li> <li>The <code>_get_model_schema</code> method was temporarily changed from a <code>@classmethod</code> to a regular method \u2014 for consistent behavior with <code>use_aliases</code>.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>use_aliases</code> is deprecated and will be removed in version 0.7.0.</li> </ul>"},{"location":"changelog/#050-2025-04-13","title":"[0.5.0] - 2025-04-13","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>AioHttpRouter for integration with the AIOHTTP framework (async support for AIOHTTP).</li> <li>Class-level cache for model schemas to improve performance (avoids regenerating JSON Schema for the same Pydantic model repeatedly).</li> <li><code>response_errors</code> parameter for route decorators to document error responses in OpenAPI.</li> <li><code>error_handler</code> module for standard error responses (provides exceptions like <code>BadRequestError</code>, <code>ResourceNotFoundError</code>, etc., as described in documentation).</li> <li>Support for using basic Python types (<code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code>) as <code>response_model</code> (for simple responses).</li> </ul>"},{"location":"changelog/#040-2025-03-20","title":"[0.4.0] - 2025-03-20","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>ReDoc UI support. A ReDoc documentation interface is now served at the default URL (e.g., <code>/redoc</code>).</li> <li>TornadoRouter for integration with the Tornado framework.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Revised and updated all tests to improve coverage and reliability.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Status code for internal error responses: changed from 422 to 500 for unhandled exceptions, providing a more appropriate HTTP status for server errors.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Removed the <code>add_docs_route</code> and <code>add_openapi_route</code> methods from <code>BaseRouter</code>. Documentation routes are now added by default, so these manual methods are no longer needed.</li> </ul>"},{"location":"changelog/#031-2025-03-15","title":"[0.3.1] - 2025-03-15","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed import issue for routers when a framework is not installed. (Guarded against <code>ModuleNotFoundError</code> if an extra was not installed and its router was imported.)</li> </ul>"},{"location":"changelog/#030-2025-03-15","title":"[0.3.0] - 2025-03-15","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>QuartRouter for integration with the Quart framework (async Flask-like framework).</li> <li>Initial documentation (introduction and basic usage examples) added to repository.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Import syntax for routers simplified: you can now do <code>from fastopenapi.routers import YourRouter</code> (e.g., <code>FlaskRouter</code>) instead of deeper module paths.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed retrieving parameters for BaseModel arguments in GET routes. Query parameters based on Pydantic models now work correctly.</li> </ul>"},{"location":"changelog/#021-2025-03-12","title":"[0.2.1] - 2025-03-12","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed an issue in internal response serialization: <code>_serialize_response</code> now correctly handles <code>BaseModel</code> instances by converting them to dict before JSON encoding (preventing a TypeError).</li> <li>Resolved a bug causing <code>DataLoader</code> to crash when processing empty datasets. (This appears to be an internal utility, possibly used for schema generation.)</li> <li>Added more tests to cover these scenarios.</li> <li>Added this <code>CHANGELOG.md</code> file to track changes.</li> </ul>"},{"location":"changelog/#020-2025-03-11","title":"[0.2.0] - 2025-03-11","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Implemented <code>resolve_endpoint_params</code> in <code>BaseRouter</code> to systematically resolve function parameters (path, query, body) and integrate with Pydantic validation.</li> <li>Added <code>prefix</code> parameter to the <code>include_router</code> method, allowing grouping routes under a path.</li> <li>Implemented <code>status_code</code> support for responses in route decorators (could specify default status code for each endpoint).</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Refactored all router implementations for consistency and to reduce code duplication.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Removed the <code>register_routes</code> method from Starlette integration (no longer needed after refactor).</li> </ul>"},{"location":"changelog/#010-2025-03-01","title":"[0.1.0] - 2025-03-01","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Initial release of FastOpenAPI.</li> <li>Core functionality implemented:</li> <li>Base classes and structure for routers.</li> <li>Router support for Falcon, Flask, Sanic, Starlette.</li> <li>OpenAPI schema generation leveraging Pydantic v2.</li> <li>Basic validation for query and body parameters.</li> <li>Included basic documentation in README and a few examples.</li> <li>Added initial test suite covering basic route registration and schema generation.</li> </ul>"},{"location":"contributing/","title":"Welcome!","text":"<p>Thanks for considering contributing to FastOpenAPI \ud83c\udf89 This guide explains how to get started, make contributions, write commits, open pull requests, and run tests.</p>"},{"location":"contributing/#setup-running","title":"Setup &amp; Running","text":"<p>Install dependencies with:</p> <pre><code># Fork the repo on GitHub first, then:\ngit clone https://github.com/yourusername/fastopenapi.git\ncd fastopenapi\npoetry install\n</code></pre> <p>If you don't use <code>poetry</code>, you can install manually from <code>pyproject.toml</code>:</p> <pre><code>pip install -e .[dev]\n</code></pre>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<ul> <li><code>fastopenapi/</code> \u2014 core library</li> <li><code>examples/</code> \u2014 examples for different frameworks</li> <li><code>tests/</code> \u2014 tests for each supported framework</li> <li><code>benchmarks/</code> \u2014 performance comparisons</li> <li><code>docs/</code> \u2014 documentation in multiple languages</li> </ul>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>To run tests:</p> <pre><code>pytest\n</code></pre> <p>Tests cover both internal logic and integration with aiohttp, flask, sanic, and more.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>This project uses:</p> <ul> <li><code>black</code> \u2014 code formatting</li> <li><code>flake8</code> \u2014 linting</li> <li><code>isort</code> \u2014 import sorting</li> <li><code>pre-commit</code> \u2014 hooks for clean code before commit</li> </ul> <p>Install pre-commit hooks:</p> <pre><code>pre-commit install\n</code></pre> <p>Run all checks manually:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#git-pull-requests","title":"Git &amp; Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a new branch: <code>feature/your-feature</code> or <code>fix/your-fix</code></li> <li>Keep commits atomic and meaningful</li> <li>Open a PR with a clear description:</li> <li>What was added/changed?</li> <li>Which frameworks were affected?</li> <li>How was it tested?</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>If your change affects public APIs or behavior, update the relevant documentation: - <code>docs/en/</code> - If possible, update other languages too (optional)</p>"},{"location":"contributing/#feedback","title":"Feedback","text":"<p>Not sure how to implement a feature? Feel free to open an issue with your proposal. We\u2019re happy to discuss it with you!</p>"},{"location":"faq/","title":"FAQ (Frequently Asked Questions)","text":"<p>Below are answers to common questions about FastOpenAPI. If you have a question that isn\u2019t covered here, feel free to reach out or open an issue on GitHub.</p>"},{"location":"faq/#q-what-is-fastopenapi-and-how-is-it-different-from-fastapi","title":"Q: What is FastOpenAPI and how is it different from FastAPI?","text":"<p>A: FastOpenAPI is not a web framework by itself, but a library to add OpenAPI/Swagger documentation and request/response validation to existing web frameworks (Flask, AIOHTTP, etc.). FastAPI is a full web framework that integrates OpenAPI generation natively. FastOpenAPI was inspired by FastAPI\u2019s developer experience but aims to provide similar benefits for frameworks that don't have automatic docs. In short: use FastAPI if you\u2019re starting fresh and want an integrated solution; use FastOpenAPI if you already have an app in another framework or need to support multiple frameworks with one tool.</p>"},{"location":"faq/#q-which-web-frameworks-are-supported-by-fastopenapi","title":"Q: Which web frameworks are supported by FastOpenAPI?","text":"<p>A: Currently supported frameworks are:</p> <ul> <li>AIOHTTP (asyncio-based HTTP server/framework)</li> <li>Falcon (both ASGI and WSGI usage)</li> <li>Flask (synchronous WSGI framework)</li> <li>Quart (Flask-like async framework)</li> <li>Sanic (async Python web framework)</li> <li>Starlette (lightweight ASGI framework)</li> <li>Tornado (Python web framework and networking library) These cover a wide range of popular Python frameworks. The architecture allows adding more, so future versions might include others. If you have a need for an unsupported framework, you could attempt to create a custom router (see Advanced Usage) or suggest it to the maintainers.</li> </ul>"},{"location":"faq/#q-what-versions-of-python-and-pydantic-are-required","title":"Q: What versions of Python and Pydantic are required?","text":"<p>A: FastOpenAPI requires Python 3.10 or above. It uses Pydantic v2 for data modeling and validation. Pydantic v2 outputs OpenAPI 3.1-compatible schemas. Ensure that your environment meets these requirements. (Pydantic v2 comes installed with FastOpenAPI by default.)</p>"},{"location":"faq/#q-how-do-i-handle-authentication-or-api-keys-in-documentation","title":"Q: How do I handle authentication or API keys in documentation?","text":"<p>A: Authentication (like JWT, OAuth2, API keys) isn't built into FastOpenAPI (since it\u2019s framework-specific typically). However, you can document authentication requirements in your OpenAPI schema. For instance, you might manually add a security scheme to the generated schema (see Advanced Usage for an example). If using an auth token header, one approach is to accept a <code>token: str</code> parameter in your endpoint and document it via <code>response_errors</code> or just mention it in the description. Actual enforcement of auth is up to your application (e.g., using middleware or decorators from your framework). FastOpenAPI\u2019s role would just be documenting the expected auth mechanism.</p>"},{"location":"faq/#q-the-docs-ui-swaggerredoc-isnt-showing-up-or-docs-returns-404-what-did-i-do-wrong","title":"Q: The docs UI (Swagger/ReDoc) isn't showing up or <code>/docs</code> returns 404. What did I do wrong?","text":"<p>A: Make sure you initialized the router with your app (<code>router = FrameworkRouter(app=app)</code>). If you forget to pass the <code>app</code>, the routes won't be registered. Also ensure your app is running and listening on the correct host/port. If running behind a proxy or under a sub-path, you might need to adjust where you look for <code>/docs</code>. By default, FastOpenAPI uses root paths for docs. If your app is mounted under a prefix, the docs might be at <code>/&lt;prefix&gt;/docs</code>. </p>"},{"location":"faq/#q-my-framework-already-has-some-docs-or-schema-generator-can-i-use-fastopenapi-alongside-it","title":"Q: My framework already has some docs or schema generator. Can I use FastOpenAPI alongside it?","text":"<p>A: If your framework has its own docs generator (like Flask-RESTx or others), it's not recommended to use two documentation generators simultaneously\u2014they might conflict or produce duplicate routes. FastOpenAPI is meant to be a standalone solution. If you choose FastOpenAPI, disable or avoid other documentation plugins for that app to prevent collisions on routes like <code>/docs</code>. If you have a specific use case to merge them, you'd likely need to do something custom.</p>"},{"location":"faq/#q-does-fastopenapi-support-dependency-injection-or-other-fastapi-features-background-tasks-middleware-injection-etc","title":"Q: Does FastOpenAPI support dependency injection or other FastAPI features (background tasks, middleware injection, etc.)?","text":"<p>A: FastOpenAPI\u2019s focus is on routing and documentation. It does not provide FastAPI\u2019s dependency injection system or some of its more advanced features. You should use the mechanisms provided by the underlying framework for things like dependency injection (for example, using Flask\u2019s <code>g</code> or app context, or Starlette\u2019s dependency functions if you manually incorporate them). FastOpenAPI will call your route function like a normal function with extracted parameters; it doesn't have a hook for dependency injection the way FastAPI does.</p>"},{"location":"faq/#q-how-stable-is-fastopenapi-for-production-use","title":"Q: How stable is FastOpenAPI for production use?","text":"<p>A: FastOpenAPI is still in early development (pre-1.0). It's being actively improved, and while many core features are in place, you should pin a version in production to avoid unexpected breaking changes on upgrade. Many users have found it useful (there's active interest on GitHub and community forums), but because it's young, there may be edge-case bugs. It's recommended to write tests around critical API functionality in your project to catch any integration issues. That said, the core of using Pydantic for validation is robust, and generating docs is read-only for your app, so the risk is manageable if you test your API.</p>"},{"location":"faq/#q-how-can-i-contribute-or-report-an-issue","title":"Q: How can I contribute or report an issue?","text":"<p>A: We welcome contributions! Check out the Contributing section of this documentation for guidelines. You can open issues on the GitHub repository for bugs, feature requests, or questions. If you have code to contribute, please fork the repo and open a Pull Request. Improving documentation, adding examples, and writing tests are also great ways to help.</p>"},{"location":"faq/#q-are-there-any-examples-of-real-projects-using-fastopenapi","title":"Q: Are there any examples of real projects using FastOpenAPI?","text":"<p>A: The FastOpenAPI repository includes an <code>examples/</code> directory covering each framework (AIOHTTP, Flask, etc.). Those can serve as a starting point. Since the project is new, real-world usage might not be widely publicized yet, but you can search the repository issues or discussions for any references to usage. Over time, as the user base grows, we expect more community examples. If you successfully use FastOpenAPI in your project, consider sharing your experience or a link for others to learn from!</p>"},{"location":"faq/#q-what-openapi-version-does-fastopenapi-generate","title":"Q: What OpenAPI version does FastOpenAPI generate?","text":"<p>A: FastOpenAPI generates an OpenAPI 3.1.0 schema (because Pydantic v2\u2019s JSON Schema output is aligned with OpenAPI 3.1). This means you can use newer features of OpenAPI (like <code>oneOf</code>, <code>anyOf</code> better support, etc.). Swagger UI and ReDoc both support OpenAPI 3.1 as of their recent versions, so the docs should display correctly. If you encounter an issue with the documentation display, ensure you have a recent version of Swagger UI/ReDoc (the ones bundled with FastOpenAPI should be up to date).</p> <p>If your question wasn\u2019t answered here, please consult the other sections of this documentation. The Usage and Advanced sections cover many details. You can also look at the repository\u2019s README and issues for more insights. FastOpenAPI is community-driven, and questions or issues you bring up could help improve the project for everyone.</p>"},{"location":"advanced/advanced_usage/","title":"Advanced Usage","text":"<p>In this section, we'll explore advanced topics such as FastOpenAPI's architecture, extending it to new frameworks, and customizing the generated documentation or behavior. This is geared more towards developers who want to understand or modify FastOpenAPI's internals or integrate it in non-standard ways.</p>"},{"location":"advanced/advanced_usage/#architecture-overview","title":"Architecture Overview","text":"<p>FastOpenAPI's design is inspired by FastAPI, but it is framework-agnostic. The core components include:</p> <ul> <li>BaseRouter: A core class that contains logic for registering routes, generating the OpenAPI schema, and handling requests/responses. It is not tied to any one framework.</li> <li>Framework-specific Routers: Subclasses of BaseRouter like <code>FlaskRouter</code>, <code>StarletteRouter</code>, etc. These implement the small differences required to hook into each framework (for example, how to actually register a route or how to attach the docs routes).</li> <li>Pydantic Models: FastOpenAPI relies on Pydantic for data modeling. Pydantic is used to define request bodies and responses, and to produce JSON Schema representations for the OpenAPI spec.</li> <li>OpenAPI Schema Generation: FastOpenAPI uses the metadata from your routes (paths, methods, parameters, models, etc.) to build an OpenAPI schema (version 3.1.0, as Pydantic v2 outputs JSON Schema compatible with OpenAPI 3.1). The schema is produced in JSON and served via the <code>/openapi.json</code> endpoint.</li> <li>Documentation UIs: FastOpenAPI includes static assets or references for Swagger UI and ReDoc. When you access <code>/docs</code> or <code>/redoc</code>, the router serves an HTML page that pulls in the respective UI (Swagger or ReDoc) and points it to the generated <code>/openapi.json</code>.</li> </ul>"},{"location":"advanced/advanced_usage/#flow-of-a-typical-request","title":"Flow of a typical request","text":"<ol> <li>A request comes into your web framework (say, Flask) for one of the documented routes.</li> <li>The request is routed to a handler function that was registered via FastOpenAPI (using the <code>@router.get/post/...</code> decorator).</li> <li>Before calling your function, FastOpenAPI (BaseRouter) will parse and validate input:</li> <li>Path params are extracted from the URL (the framework usually does this part).</li> <li>Query params, headers, and body are parsed. Query and path params are validated against the function signature (types or Pydantic models). Body is parsed into Pydantic models if specified.</li> <li>Your route function executes with the validated parameters. (If any validation failed, FastOpenAPI would have already returned an error response, so your function won't run in that case.)</li> <li>You return either data or raise an exception:</li> <li>If data is returned, FastOpenAPI will post-process it. If a <code>response_model</code> is specified, it validates and serializes the data. If not, it tries to serialize the return value directly.</li> <li>If an exception (like those from <code>fastopenapi.error_handler</code>) is raised, FastOpenAPI catches it and generates the appropriate error response.</li> <li>The framework then sends the final response to the client (which is typically JSON for both success and error cases).</li> </ol>"},{"location":"advanced/advanced_usage/#extending-to-new-frameworks","title":"Extending to New Frameworks","text":"<p>One of FastOpenAPI's goals is to be extensible. If you have a framework that\u2019s not supported out-of-the-box, you can potentially create a new router for it.</p> <p>To create a new integration:</p> <ul> <li>Subclass <code>fastopenapi.routers.BaseRouter</code>.</li> <li>Implement necessary abstract methods. For example, BaseRouter requires something like:     <ul> <li>A method to add a route to the underlying framework.</li> <li>Perhaps a method to start the application (though many frameworks don't need that encapsulated in the router).</li> <li>Ensure that the documentation routes (<code>/docs</code>, <code>/redoc</code>, <code>/openapi.json</code>) are added to the app. (In existing routers, this is often done in the BaseRouter constructor or via a helper method that each router calls.)</li> </ul> </li> <li>Look at how existing routers are implemented. For instance, <code>FlaskRouter.add_route</code> will call <code>Flask.app.add_url_rule</code>, whereas <code>StarletteRouter.add_route</code> will add it to <code>Starlette.routes</code>.</li> <li>The BaseRouter provides utility functions for generating the OpenAPI spec (<code>BaseRouter.get_openapi_schema()</code> or similar) which framework routers can use.</li> </ul> <p>For example, if integrating with Fastify (hypothetical), you would write a <code>FastifyRouter(BaseRouter)</code> and implement how to register routes in Fastify (though Fastify is Node.js, so this is just a thought exercise).</p> <p>Another scenario for extension is if you want to customize how something works in an existing router:</p> <ul> <li>You could subclass an existing router class and override methods. For instance, if you wanted a special version of <code>FlaskRouter</code> that registers routes under a URL prefix or modifies the docs path, you could subclass and change that behavior.</li> <li>You might also modify error handling or schema generation by overriding parts of BaseRouter, but that requires understanding of the internals.</li> </ul>"},{"location":"advanced/api_reference/","title":"API Reference","text":"<p>This section provides a detailed reference for FastOpenAPI classes and modules, covering interfaces, methods, and specific usage examples.</p>"},{"location":"advanced/api_reference/#file-structure","title":"File Structure","text":"<p>FastOpenAPI follows a modular architecture:</p> <pre><code>fastopenapi/\n\u251c\u2500\u2500 base_router.py\n\u2514\u2500\u2500 routers/\n    \u251c\u2500\u2500 aiohttp.py\n    \u251c\u2500\u2500 falcon.py\n    \u251c\u2500\u2500 flask.py\n    \u251c\u2500\u2500 quart.py\n    \u251c\u2500\u2500 sanic.py\n    \u251c\u2500\u2500 starlette.py\n    \u2514\u2500\u2500 tornado.py\n</code></pre>"},{"location":"advanced/api_reference/#baserouter","title":"BaseRouter","text":"<p>Description: Abstract base class providing common routing and OpenAPI schema generation functionality. Usually not instantiated directly, but inherited by framework-specific routers.</p>"},{"location":"advanced/api_reference/#key-methods","title":"Key Methods","text":"<ul> <li><code>__init__(app, docs_url=\"/docs\", redoc_url=\"/redoc\", openapi_url=\"/openapi.json\", openapi_version=\"3.0.0\", title=\"My App\", version=\"0.1.0\", description=\"API documentation\")</code></li> <li><code>get(path, **options)</code>: Defines a GET route.</li> <li><code>post(path, **options)</code>: Defines a POST route.</li> <li><code>put(path, **options)</code>: Defines a PUT route.</li> <li><code>patch(path, **options)</code>: Defines a PATCH route.</li> <li><code>delete(path, **options)</code>: Defines a DELETE route.</li> <li><code>include_router(other_router, prefix=\"\")</code>: Includes another router's endpoints under a prefix.</li> <li><code>generate_openapi_schema()</code>: Generates OpenAPI schema.</li> </ul>"},{"location":"advanced/api_reference/#attributes","title":"Attributes","text":"<ul> <li><code>app</code>: Framework-specific application instance.</li> <li><code>docs_url</code>, <code>redoc_url</code>, <code>openapi_url</code>: URLs for documentation endpoints.</li> <li><code>title</code>, <code>description</code>, <code>version</code>: Metadata for OpenAPI schema.</li> </ul>"},{"location":"advanced/api_reference/#framework-routers","title":"Framework Routers","text":"<p>Each router class inherits from <code>BaseRouter</code> and integrates with a specific framework.</p>"},{"location":"advanced/api_reference/#aiohttprouter","title":"AioHttpRouter","text":"<p>Use for AIOHTTP integration.</p> <pre><code>from aiohttp import web\nfrom fastopenapi.routers import AioHttpRouter\n\napp = web.Application()\nrouter = AioHttpRouter(app=app)\n\n@router.get(\"/status\")\nasync def status():\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"advanced/api_reference/#falconrouter","title":"FalconRouter","text":"<p>Use for Falcon ASGI integration.</p> <pre><code>import falcon.asgi\nfrom fastopenapi.routers import FalconRouter\n\napp = falcon.asgi.App()\nrouter = FalconRouter(app=app)\n\n@router.get(\"/status\")\nasync def status():\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"advanced/api_reference/#flaskrouter","title":"FlaskRouter","text":"<p>Use for Flask integration.</p> <pre><code>from flask import Flask\nfrom fastopenapi.routers import FlaskRouter\n\napp = Flask(__name__)\nrouter = FlaskRouter(app=app)\n\n@router.get(\"/hello\")\ndef hello(name: str):\n    return {\"message\": f\"Hello {name}\"}\n</code></pre>"},{"location":"advanced/api_reference/#quartrouter","title":"QuartRouter","text":"<p>Use for Quart integration (async).</p> <pre><code>from quart import Quart\nfrom fastopenapi.routers import QuartRouter\n\napp = Quart(__name__)\nrouter = QuartRouter(app=app)\n\n@router.get(\"/ping\")\nasync def ping():\n    return {\"pong\": True}\n</code></pre>"},{"location":"advanced/api_reference/#sanicrouter","title":"SanicRouter","text":"<p>Use for Sanic integration.</p> <pre><code>from sanic import Sanic\nfrom fastopenapi.routers import SanicRouter\n\napp = Sanic(\"MySanicApp\")\nrouter = SanicRouter(app=app)\n\n@router.get(\"/info\")\nasync def info():\n    return {\"framework\": \"Sanic\", \"status\": \"running\"}\n</code></pre>"},{"location":"advanced/api_reference/#starletterouter","title":"StarletteRouter","text":"<p>Use for Starlette integration.</p> <pre><code>from starlette.applications import Starlette\nfrom fastopenapi.routers import StarletteRouter\n\napp = Starlette()\nrouter = StarletteRouter(app=app)\n\n@router.get(\"/check\")\nasync def check():\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"advanced/api_reference/#tornadorouter","title":"TornadoRouter","text":"<p>Use for Tornado integration.</p> <pre><code>from tornado.web import Application\nfrom fastopenapi.routers import TornadoRouter\n\napp = Application()\nrouter = TornadoRouter(app=app)\n\n@router.get(\"/status\")\ndef status():\n    return {\"running\": True}\n</code></pre>"},{"location":"advanced/api_reference/#example-with-sub-router","title":"Example with Sub-router","text":"<pre><code>api_v1 = &lt;Framework&gt;Router()\n\n@api_v1.get(\"/users\")\ndef users():\n    return [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n\nmain_router = &lt;Framework&gt;Router(app=app)\nmain_router.include_router(api_v1, prefix=\"/v1\")\n</code></pre>"},{"location":"advanced/api_reference/#exception-handling","title":"Exception Handling","text":""},{"location":"advanced/api_reference/#built-in-exceptions","title":"Built-in Exceptions","text":"<p>Use built-in exceptions for clear HTTP error responses.</p> <pre><code>from fastopenapi.error_handler import BadRequestError, ResourceNotFoundError\n\n@router.get(\"/validate\")\ndef validate_input(param: int):\n    if param &lt; 0:\n        raise BadRequestError(\"Parameter must be positive\")\n\n@router.get(\"/items/{item_id}\")\ndef get_item(item_id: int):\n    item = db.get(item_id)\n    if item is None:\n        raise ResourceNotFoundError(f\"Item {item_id} not found\")\n</code></pre>"},{"location":"advanced/api_reference/#framework-specific-exceptions","title":"Framework-specific Exceptions","text":"<p>Use framework-specific exceptions if you do not want to use exceptions from FastOpenAPI.</p>"},{"location":"advanced/api_reference/#aiohttp","title":"AioHTTP","text":"<pre><code>from aiohttp import web\n\n@router.get(\"/notfound\")\ndef aiohttp_notfound():\n    raise web.HTTPNotFound(reason=\"Not Found\")\n</code></pre>"},{"location":"advanced/api_reference/#falcon","title":"Falcon","text":"<pre><code>import falcon\n\n@router.get(\"/notfound\")\nasync def falcon_notfound():\n    raise falcon.HTTPNotFound(title=\"Not Found\", description=\"Falcon error\")\n</code></pre>"},{"location":"advanced/api_reference/#flask","title":"Flask","text":"<pre><code>from flask import abort\n\n@router.get(\"/notfound\")\ndef flask_notfound():\n    abort(404, description=\"Flask error\")\n</code></pre>"},{"location":"advanced/api_reference/#quart","title":"Quart","text":"<pre><code>from quart import abort\n\n@router.get(\"/notfound\")\nasync def quart_notfound():\n    abort(404, description=\"Quart error\")\n</code></pre>"},{"location":"advanced/api_reference/#sanic","title":"Sanic","text":"<pre><code>from sanic import NotFound\n\n@router.get(\"/notfound\")\nasync def sanic_notfound():\n    raise NotFound()\n</code></pre>"},{"location":"advanced/api_reference/#starlette","title":"Starlette","text":"<pre><code>from starlette.exceptions import HTTPException\n\n@router.get(\"/notfound\")\nasync def starlette_notfound():\n    raise HTTPException(status_code=404, detail=\"Not Found\")\n</code></pre>"},{"location":"advanced/api_reference/#tornado","title":"Tornado","text":"<pre><code>from tornado.web import HTTPError\n\n@router.get(\"/notfound\")\nasync def tornado_notfound():\n    raise HTTPError(status_code=404, reason=\"Not Found\")\n</code></pre>"},{"location":"frameworks/aiohttp/","title":"AIOHTTP Integration","text":"<p>This guide covers how to use FastOpenAPI with AIOHTTP (an asynchronous HTTP framework).</p> <p>AIOHTTP applications are usually built with an <code>aiohttp.web.Application</code> and run using <code>aiohttp.web.run_app</code>. FastOpenAPI provides an <code>AioHttpRouter</code> to integrate with this.</p>"},{"location":"frameworks/aiohttp/#setup","title":"Setup","text":"<p>Make sure you have installed FastOpenAPI:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>or</p> <pre><code>pip install fastopenapi[aiohttp]\n</code></pre>"},{"location":"frameworks/aiohttp/#hello-world","title":"Hello World","text":"<pre><code>from aiohttp import web\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import AioHttpRouter\n\napp = web.Application()\nrouter = AioHttpRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from AIOHTTP\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's aiohttp!\")\n\nif __name__ == \"__main__\":\n    web.run_app(app, host=\"127.0.0.1\", port=8000)\n\n</code></pre>"},{"location":"frameworks/aiohttp/#project-example","title":"Project Example","text":"<p>See example for this framework in the <code>examples/aiohttp/</code> directory of the repository.</p>"},{"location":"frameworks/falcon/","title":"Falcon Integration","text":"<p>This guide covers using FastOpenAPI with Falcon, a high-performance web framework.</p> <p>FastOpenAPI's <code>FalconRouter</code> supports Falcon, particularly via Falcon's ASGI interface for asynchronous operation.</p>"},{"location":"frameworks/falcon/#setup","title":"Setup","text":"<p>Install FastOpenAPI:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>or</p> <pre><code>pip install fastopenapi[falcon]\n</code></pre>"},{"location":"frameworks/falcon/#hello-world","title":"Hello World","text":"<pre><code>import falcon.asgi\nimport uvicorn\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import FalconRouter\n\napp = falcon.asgi.App()           # Falcon ASGI app (for async support)\nrouter = FalconRouter(app=app)    # Attach FastOpenAPI router\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Falcon\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Falcon!\")\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n</code></pre>"},{"location":"frameworks/falcon/#project-example","title":"Project Example","text":"<p>See example for this framework in the <code>examples/falcon/</code> directory of the repository.</p>"},{"location":"frameworks/flask/","title":"Flask Integration","text":"<p>This guide demonstrates FastOpenAPI integration with Flask, one of the most popular Python web frameworks.</p> <p>The <code>FlaskRouter</code> class ties FastOpenAPI into the Flask routing system.</p>"},{"location":"frameworks/flask/#setup","title":"Setup","text":"<p>Install FastOpenAPI:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>or</p> <pre><code>pip install fastopenapi[flask]\n</code></pre>"},{"location":"frameworks/flask/#hello-world","title":"Hello World","text":"<pre><code>from flask import Flask\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import FlaskRouter\n\napp = Flask(__name__)\nrouter = FlaskRouter(app=app)  # Attach FastOpenAPI to the Flask app\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Say hello from Flask\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Flask!\")\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n\n</code></pre>"},{"location":"frameworks/flask/#project-example","title":"Project Example","text":"<p>See example for this framework in the <code>examples/flask/</code> directory of the repository.</p>"},{"location":"frameworks/quart/","title":"Quart Integration","text":"<p>Quart is an async web framework with a Flask-like API (it\u2019s a drop-in replacement for Flask but with async support).</p> <p>FastOpenAPI provides <code>QuartRouter</code> for integrating with Quart.</p>"},{"location":"frameworks/quart/#setup","title":"Setup","text":"<p>Install FastOpenAPI:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>or</p> <pre><code>pip install fastopenapi[quart]\n</code></pre>"},{"location":"frameworks/quart/#hello-world","title":"Hello World","text":"<pre><code>from quart import Quart\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import QuartRouter\n\napp = Quart(__name__)\nrouter = QuartRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Quart\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Quart!\")\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n\n</code></pre>"},{"location":"frameworks/quart/#project-example","title":"Project Example","text":"<p>See example for this framework in the <code>examples/quart/</code> directory of the repository.</p>"},{"location":"frameworks/sanic/","title":"Sanic Integration","text":"<p>Sanic is an async web framework known for its speed.</p> <p>FastOpenAPI can integrate with Sanic through the <code>SanicRouter</code>.</p>"},{"location":"frameworks/sanic/#setup","title":"Setup","text":"<p>Install FastOpenAPI:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>or</p> <pre><code>pip install fastopenapi[sanic]\n</code></pre>"},{"location":"frameworks/sanic/#hello-world","title":"Hello World","text":"<pre><code>from sanic import Sanic\nfrom pydantic import BaseModel\nfrom fastopenapi.routers import SanicRouter\n\napp = Sanic(\"MySanicApp\")\nrouter = SanicRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Sanic\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Sanic!\")\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)\n\n</code></pre>"},{"location":"frameworks/sanic/#project-example","title":"Project Example","text":"<p>See example for this framework in the <code>examples/sanic/</code> directory of the repository.</p>"},{"location":"frameworks/starlette/","title":"Starlette Integration","text":"<p>Starlette is a lightweight ASGI framework which FastAPI itself is built upon.</p> <p>FastOpenAPI's <code>StarletteRouter</code> allows you to use FastOpenAPI directly with Starlette applications.</p>"},{"location":"frameworks/starlette/#setup","title":"Setup","text":"<p>Install FastOpenAPI:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>or</p> <pre><code>pip install fastopenapi[starlette]\n</code></pre>"},{"location":"frameworks/starlette/#hello-world","title":"Hello World","text":"<pre><code>import uvicorn\nfrom pydantic import BaseModel\nfrom starlette.applications import Starlette\nfrom fastopenapi.routers import StarletteRouter\n\napp = Starlette()\nrouter = StarletteRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Starlette\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Starlette!\")\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n</code></pre>"},{"location":"frameworks/starlette/#project-example","title":"Project Example","text":"<p>See example for this framework in the <code>examples/starlette/</code> directory of the repository.</p>"},{"location":"frameworks/tornado/","title":"Tornado Integration","text":"<p>Tornado is a mature Python web framework and asynchronous networking library.</p> <p>FastOpenAPI supports Tornado via the <code>TornadoRouter</code>, allowing you to add OpenAPI documentation to Tornado applications.</p>"},{"location":"frameworks/tornado/#setup","title":"Setup","text":"<p>Install FastOpenAPI:</p> <pre><code>pip install fastopenapi\n</code></pre> <p>or</p> <pre><code>pip install fastopenapi[tornado]\n</code></pre>"},{"location":"frameworks/tornado/#hello-world","title":"Hello World","text":"<pre><code>import asyncio\nfrom pydantic import BaseModel\nfrom tornado.web import Application\nfrom fastopenapi.routers import TornadoRouter\n\napp = Application()\nrouter = TornadoRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Say hello from Tornado\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Tornado!\")\n\nasync def main():\n    app.listen(8000)\n    await asyncio.Event().wait()  # Keep running\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n</code></pre>"},{"location":"frameworks/tornado/#project-example","title":"Project Example","text":"<p>See example for this framework in the <code>examples/tornado/</code> directory of the repository.</p>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>FastOpenAPI is available on PyPI and supports Python 3.10+. You can install the core library or include optional dependencies for specific web frameworks. </p>"},{"location":"getting_started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher \u2013 FastOpenAPI requires Python 3.10+ due to its use of modern typing features and Pydantic v2.</li> <li>(Optional) An existing web framework (such as Flask, Starlette, etc.) if you plan to integrate with one. If you don't have the framework installed, using the appropriate extra in pip (as shown below) will install it for you.</li> </ul>"},{"location":"getting_started/installation/#using-pip","title":"Using pip","text":""},{"location":"getting_started/installation/#install-only-fastopenapi","title":"Install only FastOpenAPI","text":"<p>The ordinary installation</p> <pre><code>pip install fastopenapi\n</code></pre>"},{"location":"getting_started/installation/#install-fastopenapi-with-a-specific-framework","title":"Install FastOpenAPI with a specific framework","text":"<p>Useful if you're starting a new service and haven't installed a framework yet</p> <pre><code>pip install fastopenapi[aiohttp]\n</code></pre> <pre><code>pip install fastopenapi[falcon]\n</code></pre> <pre><code>pip install fastopenapi[flask]\n</code></pre> <pre><code>pip install fastopenapi[quart]\n</code></pre> <pre><code>pip install fastopenapi[sanic]\n</code></pre> <pre><code>pip install fastopenapi[starlette]\n</code></pre> <pre><code>pip install fastopenapi[tornado]\n</code></pre>"},{"location":"getting_started/quickstart/","title":"Quickstart","text":"<p>This quickstart will guide you through adding FastOpenAPI to a simple application and viewing the generated API documentation.</p>"},{"location":"getting_started/quickstart/#step-0-install-the-library","title":"Step 0. Install the library","text":"<p>Follow the instructions from Installation</p>"},{"location":"getting_started/quickstart/#step-1-create-an-application","title":"Step 1. Create an application","text":"<ul> <li>Create the <code>main.py</code> file</li> <li>Copy the code from an example</li> <li>For some examples uvicorn is required (<code>pip install uvicorn</code>)</li> </ul>"},{"location":"getting_started/quickstart/#examples","title":"Examples","text":""},{"location":"getting_started/quickstart/#aiohttp","title":"AioHTTP","text":"Click to expand the AioHttp Example <pre><code>from aiohttp import web\nfrom pydantic import BaseModel\n\nfrom fastopenapi.routers import AioHttpRouter\n\napp = web.Application()\nrouter = AioHttpRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from aiohttp\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's aiohttp!\")\n\n\nif __name__ == \"__main__\":\n    web.run_app(app, host=\"127.0.0.1\", port=8000)\n</code></pre>"},{"location":"getting_started/quickstart/#falcon","title":"Falcon","text":"Click to expand the Falcon Example <pre><code>import falcon.asgi\nimport uvicorn\nfrom pydantic import BaseModel\n\nfrom fastopenapi.routers import FalconRouter\n\napp = falcon.asgi.App()\nrouter = FalconRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Falcon\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Falcon!\")\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#flask","title":"Flask","text":"Click to expand the Flask Example <pre><code>from flask import Flask\nfrom pydantic import BaseModel\n\nfrom fastopenapi.routers import FlaskRouter\n\napp = Flask(__name__)\nrouter = FlaskRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Say hello from Flask\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Flask!\")\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#quart","title":"Quart","text":"Click to expand the Quart Example <pre><code>from pydantic import BaseModel\nfrom quart import Quart\n\nfrom fastopenapi.routers import QuartRouter\n\napp = Quart(__name__)\nrouter = QuartRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Quart\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Quart!\")\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#sanic","title":"Sanic","text":"Click to expand the Sanic Example <pre><code>from pydantic import BaseModel\nfrom sanic import Sanic\n\nfrom fastopenapi.routers import SanicRouter\n\napp = Sanic(\"MySanicApp\")\nrouter = SanicRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Sanic\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Sanic!\")\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#starlette","title":"Starlette","text":"Click to expand the Starlette Example <pre><code>import uvicorn\nfrom pydantic import BaseModel\nfrom starlette.applications import Starlette\n\nfrom fastopenapi.routers import StarletteRouter\n\napp = Starlette()\nrouter = StarletteRouter(app=app)\n\n\nclass HelloResponse(BaseModel):\n    message: str\n\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\nasync def hello(name: str):\n    \"\"\"Say hello from Starlette\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Starlette!\")\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n</code></pre>"},{"location":"getting_started/quickstart/#tornado","title":"Tornado","text":"Click to expand the Tornado Example <pre><code>import asyncio\nfrom pydantic import BaseModel\nfrom tornado.web import Application\nfrom fastopenapi.routers.tornado import TornadoRouter\n\napp = Application()\nrouter = TornadoRouter(app=app)\n\nclass HelloResponse(BaseModel):\n    message: str\n\n@router.get(\"/hello\", tags=[\"Hello\"], status_code=200, response_model=HelloResponse)\ndef hello(name: str):\n    \"\"\"Say hello from Tornado\"\"\"\n    return HelloResponse(message=f\"Hello, {name}! It's Tornado!\")\n\nasync def main():\n    app.listen(8000)\n    await asyncio.Event().wait()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n</code></pre>"},{"location":"getting_started/quickstart/#step-2-run-the-server","title":"Step 2. Run the server","text":""},{"location":"getting_started/quickstart/#launch-the-application","title":"Launch the application:","text":"<pre><code>python main.py\n</code></pre> <p>Once launched, the documentation will be available at:</p>"},{"location":"getting_started/quickstart/#swagger-ui","title":"Swagger UI","text":"<pre><code>http://127.0.0.1:8000/docs\n</code></pre> <p>You can see the automatic interactive API documentation (provided by Swagger UI):</p> <p></p>"},{"location":"getting_started/quickstart/#redoc","title":"ReDoc","text":"<pre><code>http://127.0.0.1:8000/redoc\n</code></pre> <p>You can see another automatic documentation (provided by ReDoc):</p> <p></p>"},{"location":"getting_started/quickstart/#generated-documentation","title":"Generated Documentation","text":"<p>Once the server is running, documentation is automatically available:</p> <ul> <li>Swagger UI: http://localhost:8000/docs</li> <li>ReDoc: http://localhost:8000/redoc</li> <li>OpenAPI JSON: http://localhost:8000/openapi.json</li> </ul>"},{"location":"getting_started/usage/","title":"Usage","text":"<p>This section explains how to use FastOpenAPI to document and validate your API endpoints. Below you will find separate examples for each usage scenario, including handling of both library and framework exceptions.</p>"},{"location":"getting_started/usage/#defining-endpoints","title":"Defining Endpoints","text":""},{"location":"getting_started/usage/#available-methods","title":"Available methods","text":"<ul> <li><code>@router.get(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.post(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.patch(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.put(path, response_errors, response_model, tags, status_code)</code></li> <li><code>@router.delete(path, response_errors, response_model, tags, status_code)</code></li> </ul>"},{"location":"getting_started/usage/#short-descriptions","title":"Short descriptions","text":"<ul> <li><code>path</code> - the method URL.</li> <li><code>response_errors</code> - the list of error codes for your method.</li> <li><code>response_model</code> - your Pydantic model. You can use int, float, str, bool as well.</li> <li><code>tags</code> - OpenAPI tags for your handler.</li> <li><code>status_code</code> - the success response code.</li> </ul>"},{"location":"getting_started/usage/#examples-for-methods","title":"Examples for methods","text":"<pre><code>from pydantic import BaseModel\nfrom typing import Optional\n\n# Don't use this router. It's just an example.\nfrom fastopenapi.base_router import BaseRouter\n\nclass CreateUserRequest(BaseModel):\n    name: str\n    surname: str\n    age: int\n\nclass UpdateUserRequest(BaseModel):\n    name: Optional[str]\n    surname: Optional[str]\n    age: Optional[int]\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    surname: str\n    age: int\n\nrouter = BaseRouter()\n\n@router.get(\"/user/{user_id}\", tags=[\"User\"], status_code=200, response_model=UserResponse)\ndef get_user(user_id: int):\n    # your getting logic here\n    data = {}\n    return UserResponse(**data)\n\n@router.post(\"/user\", tags=[\"User\"], status_code=201, response_model=UserResponse)\ndef create_user(user_data: CreateUserRequest):\n    # your creating logic here\n    data = {}\n    return UserResponse(**data)\n\n@router.patch(\"/user/{user_id}\", tags=[\"User\"], status_code=200, response_model=UserResponse)\ndef update_user(user_id: int, user_data: UpdateUserRequest):\n    # your updating logic here\n    data = {}\n    return UserResponse(**data)\n\n@router.delete(\"/user/{user_id}\", tags=[\"User\"], status_code=204)\ndef delete_user(user_id: int):\n    # your deleting logic here\n    return None\n</code></pre>"},{"location":"getting_started/usage/#basic-request-listing-items","title":"Basic request (Listing Items)","text":"<pre><code>@router.get(\"/items\")\nasync def list_items():\n    return {\"items\": [\"foo\", \"bar\"]}\n</code></pre>"},{"location":"getting_started/usage/#request-with-path-parameter","title":"Request with Path Parameter","text":"<pre><code>@router.get(\"/items/{item_id}\")\nasync def get_item(item_id: int):\n    item = database.get(item_id)\n    if item is None:\n        # You can use framework-specific exception here \n        raise ResourceNotFoundError(f\"Item {item_id} not found\")\n    return item\n</code></pre>"},{"location":"getting_started/usage/#handling-query-parameters","title":"Handling Query Parameters","text":"<pre><code>@router.get(\"/search\")\nasync def search(q: str = \"\", limit: int = 10):\n    if limit &lt; 0:\n        # You can use framework-specific exception here \n        raise BadRequestError(\"Limit must be non-negative\")\n    return {\"query\": q, \"limit\": limit}\n</code></pre>"},{"location":"getting_started/usage/#handling-request-bodies-with-pydantic-models","title":"Handling Request Bodies with Pydantic Models","text":"<pre><code>from flask import abort\nfrom pydantic import BaseModel\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n@router.post(\"/items\", response_model=Item, status_code=201)\ndef create_item(item: Item):\n    try:\n        save_to_database(item)\n    except DatabaseError as e:\n        abort(500, description=\"Database error\")\n    return item\n</code></pre>"},{"location":"getting_started/usage/#organizing-code-with-sub-routers","title":"Organizing Code with Sub-Routers","text":"<p>File: users.py</p> <pre><code>from fastopenapi.routers import StarletteRouter\nfrom pydantic import BaseModel\nfrom typing import List\n\nuser_router = StarletteRouter()\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n@user_router.get(\"/users\", response_model=List[User])\nasync def list_users():\n    return [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\n\n@user_router.post(\"/users\", response_model=User, status_code=201)\nasync def create_user(user: User):\n    save_user_to_database(user)\n    return user\n</code></pre> <p>File: main.py</p> <pre><code>from fastopenapi.routers import StarletteRouter\nfrom starlette.applications import Starlette\nfrom users import user_router\n\napp = Starlette()\nmain_router = StarletteRouter(app=app)\nmain_router.include_router(user_router, prefix=\"/v1\")\n</code></pre>"},{"location":"getting_started/usage/#exception-handling-examples","title":"Exception Handling Examples","text":""},{"location":"getting_started/usage/#library-exceptions","title":"Library Exceptions","text":"<pre><code>from fastopenapi.error_handler import ResourceNotFoundError\n\n@router.get(\"/products/{product_id}\")\nasync def get_product(product_id: int):\n    product = database.get_product(product_id)\n    if product is None:\n        # You can use framework-specific exception here \n        raise ResourceNotFoundError(f\"Product {product_id} not found\")\n    return product\n</code></pre>"},{"location":"getting_started/usage/#framework-specific-exceptions","title":"Framework-Specific Exceptions","text":""},{"location":"getting_started/usage/#flask-example","title":"Flask Example","text":"<pre><code>from flask import abort\n\n@router.get(\"/orders/{order_id}\")\ndef get_order(order_id: int):\n    order = get_order_from_db(order_id)\n    if order is None:\n        abort(404, description=\"Order not found\")\n    return order\n</code></pre>"},{"location":"getting_started/usage/#falcon-example","title":"Falcon Example","text":"<pre><code>import falcon\n\n@router.get(\"/invoices/{invoice_id}\")\nasync def get_invoice(invoice_id: int):\n    invoice = database.get_invoice(invoice_id)\n    if invoice is None:\n        raise falcon.HTTPNotFound(title=\"Not Found\", description=\"Invoice not found\")\n    return invoice\n</code></pre> <p>These examples demonstrate how you can:</p> <ul> <li>Define routes with various parameter types (path, query, body);</li> <li>Use Pydantic for request and response validation and automatic OpenAPI schema generation;</li> <li>Handle errors using both FastOpenAPI's built-in exception classes and framework-specific exceptions.</li> </ul>"},{"location":"getting_started/usage/#project-examples","title":"Project Examples","text":"<p>See examples for each supported framework in the <code>examples/</code> directory of the repository.</p>"}]}